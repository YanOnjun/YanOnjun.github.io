[{"title":"设计模式","url":"/2023/04/05/通用/设计模式/","content":"\n# 软件开发原则\n\n## 单一职责原则\n\n**对于一个类只有一个引起它变化的原因**\n\n一个类只负责尽可能独立的一项功能，尽可能少的职责\n\n优点：\n\n（1）功能单一，职责清晰。\n\n（2）增强可读性，方便维护。\n\n缺点：\n\n（1）拆分得太详细，类的数量会急剧增加。\n\n（2）职责的度量没有统一的标准，需要根据项目实现情况而定。\n\n\n\n## 开放封闭原则\n\n**对于扩展是开放的（Open for extension），对于更改是封闭的（Closed for modification）**\n\n无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。但是预先猜测是很难的，所以等到变化发生时立即采取行动，创建抽象来隔离以后发生的同类变化。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\n\n开放-封闭原则是面向对象设计的核心所在。\n\n\n\n## 里氏代换原则\n\n**子类型必须能够替换掉它们的父类型** \n\n> 「一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化」\n\n只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。\n\n依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。\n\n\n\n## 依赖倒转原则\n\n**针对接口编程，不要对实现编程**\n\n**依赖倒转原则**\n\n- A．高层模块不应该依赖低层模块。两个都应该依赖抽象。\n- B．抽象不应该依赖细节。细节应该依赖抽象。\n\n> 做新项目时，发现业务逻辑的高层模块都是一样的，但客户却希望使用不同的数据库或存储信息方式，这时就出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与低层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。\n\n\n\n# 设计模式分类\n\n- 创建型模式\n  - 工厂方法模式\n- 行为型模式：类或者对象之间交互的行为，如何划分职责、更好的完成任务\n  - 策略模式\n- 结构型模式：将类和对象结合在一起形成一个更强大的结构\n  - 装饰模式\n\n\n\n# 工厂模式\n\n通过工厂实例化对象\n\n\n\n# 策略模式\n\n> 策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n策略模式是一种定义一系列算法的方法。这些算法完成的都是相同的工作，只是实现不同，策略模式用相同的方法调用所有的算法，减少各种算法类与使用算法类之间的耦合。\n\n策略模式的Strategy类层次为Context定义了一系列可供重用的算法和行为，提取出这些算法和行为中的公共功能。\n\n## 使用原因\n\n不同的行为放在一个类中，难以避免使用条件判断选择行为：\n\n```java\npublic class Strategy {\n    //算法方法\n    public void AlgorithmInterface(){\n        if (条件A) {\n            System.out.println(\"算法A实现\");\n        }else if (条件B) {\n            System.out.println(\"算法B实现\");\n        }else if (条件C) {\n            System.out.println(\"算法C实现\");\n        }\n    }\n}\n```\n\n## 示例\n\n将行为封装在独立的Strategy子类，根据不同的子类调用行为方法消除条件语句。\n\n调用不同算法的示例：\n\n```java\n/**\n * 策略模式\n * 抽象算法类\n * 定义所有支持的算法的公共接口\n */\npublic abstract class Strategy {\n    //算法方法\n    public abstract void AlgorithmInterface();\n}\n\n//具体算法A\nclass ConcreteStrategyA extends Strategy {\n\n    //算法A实现方法\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println(\"算法A实现\");\n    }\n}\n\n//具体算法B\nclass ConcreteStrategyB extends Strategy {\n    //算法B实现方法\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println(\"算法B实现\");\n    }\n}\n\n//具体算法C\nclass ConcreteStrategyC extends Strategy {\n    //算法C实现方法\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println(\"算法C实现\");\n    }\n}\n```\n\n\n```java\n/**\n* 上下文核心\n*/\npublic class Context {\n\n    Strategy strategy;\n\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void ContextInterface() {\n        strategy.AlgorithmInterface();\n    }\n\n    public static void main(String[] args) {\n        // 由于实例化不同的策略，最终调用context.ContextInterface时的结果也不同\n        Context context = new Context(new ConcreteStrategyA());\n        context.ContextInterface();\n        context = new Context(new ConcreteStrategyB());\n        context.ContextInterface();\n        context = new Context(new ConcreteStrategyC());\n        context.ContextInterface();\n    }\n}\n```\n\n\n\n## 策略模式和工厂模式的结合\n\n```java\npublic Context(String type) {\n    switch (type) {\n        case \"A\":\n            this.strategy = new ConcreteStrategyA();\n            break;\n        case \"B\":\n            this.strategy = new ConcreteStrategyB();\n            break;\n        case \"C\":\n            this.strategy = new ConcreteStrategyC();\n            break;\n    }\n}\n\n        Context context1 = new Context(\"A\");\n        context1.ContextInterface();\n```\n\n在这种情况下，客户端只接触到了 Context 类， 没有接触到算法抽象类 Strategy，具体的算法彻底与客户端分离， 耦合更加降低。\n\n## 使用场景\n\n在不同情况下使用不同的业务规则，考虑使用策略模式处理这种变化\n\n\n\n# 装饰模式\n\n动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n\n装饰模式是为已有功能动态地添加更多功能的一种方式。\n\n**装饰模式的优点：**\n\n有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。\n\n## 使用原因\n\n当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为。但这种做法的问题在于，它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。\n\n```java\n/**\n * version 1\n * 装饰模式\n * 人穿衣服，给Person类添加穿某个衣服动作\n */\npublic class Person1 {\n\n    String name;\n\n    public Person1(String name) {\n        this.name = name;\n    }\n\n    public void wearTShirt() {\n        System.out.print(\"T恤 \");\n    }\n\n    public void wearJeans() {\n        System.out.print(\"牛仔裤 \");\n    }\n\n    public void wearJacket () {\n        System.out.print(\"夹克 \");\n    }\n\n    //..... 等等穿方法 如果要增加装扮，需要修改person类 违背开闭原则\n\n    public void show() {\n        System.out.println(\"穿好了\");\n    }\n\n\n    public static void main(String[] args) {\n        Person1 person1 = new Person1(\"上春\");\n        System.out.println(\"穿衣服：\");\n        person1.wearTShirt();\n        person1.wearJeans();\n        person1.wearJacket();\n        person1.show();\n    }\n}\n```\n\n\n\n```java\n/**\n * version2\n * 提取穿衣服动作，抽象衣服 实现开闭原则\n */\npublic class Person2 {\n    String name;\n\n    public Person2(String name) {\n        this.name = name;\n    }\n\n    public void show() {\n        System.out.println(name + \" 穿好了\");\n    }\n\n    // 做到了服饰与人 类的分离，但是这种方式衣服与人无关 只是将衣服一个一个词输出\n    public static void main(String[] args) {\n        Person2 person1 = new Person2(\"上春\");\n        TShirt ts = new TShirt();\n        Jeans nzk = new Jeans();\n        Jacket jk = new Jacket();\n        System.out.println(\"穿衣服：\");\n        ts.show();\n        nzk.show();\n        jk.show();\n        person1.show();\n    }\n\n}\n\n/**\n * 服饰父类\n */\nabstract class Finery {\n\n    public abstract void show ();\n}\n\nclass TShirt extends  Finery {\n    @Override\n    public void show() {\n        System.out.print(\"T恤 \");\n    }\n}\n\nclass Jeans extends  Finery {\n    @Override\n    public void show() {\n        System.out.print(\"牛仔裤 \");\n    }\n}\n\nclass Jacket extends  Finery {\n    @Override\n    public void show() {\n        System.out.print(\"夹克 \");\n    }\n}\n```\n\n装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。\n\n## 示例\n\n```java\n/**\n * version3\n * 装饰模式\n * 动态的给对象添加额外的职责，增加功能\n * 使用Person2\n */\npublic class Person3 {\n\n    public static void main(String[] args) {\n        Person2 person1 = new Person2(\"上春\");\n        TShirt tShirt = new TShirt();\n        Jacket jk = new Jacket();\n        Jeans nzk = new Jeans();\n\n        tShirt.Decorate(person1);\n        jk.Decorate(tShirt);\n        nzk.Decorate(jk);\n        nzk.show();\n    }\n}\nclass Finery2 extends Person2 {\n\n    // 被拓展的对象\n    Person2 person;\n\n    public void Decorate (Person2 person) {\n        this.person = person;\n    }\n\n    public void show() {\n        // 这里不是super.show 调用person.show 实际上是子类中调用实现对person.show方法的拓展\n        if(person != null) {\n            person.show();\n        }\n    }\n}\n\nclass TShirt extends Finery2 {\n    @Override\n    public void show() {\n        System.out.print(\"T恤 \");\n        super.show();\n    }\n}\n\nclass Jeans extends Finery2 {\n    @Override\n    public void show() {\n        System.out.print(\"牛仔裤 \");\n        super.show();\n    }\n}\n\nclass Jacket extends Finery2 {\n    @Override\n    public void show() {\n        System.out.print(\"夹克 \");\n        super.show();\n    }\n}\n```\n\n","tags":["通用技术"],"categories":["技术"]},{"title":"读书笔记-优势成长","url":"/2023/03/26/读书笔记/读书笔记-优势成长/","tags":["个人成长"],"categories":["读书笔记"]},{"title":"资源分享","url":"/2023/03/26/通用/资源/","content":"\n\n\n# 【架构师】零基础到精通——高可用\n\n https://articles.zsxq.com/id_wfrwhhkqn8x3.html\n\n# 数据结构可视化\n\nhttp://www.rmboot.com/Algorithms.html\n\n# Java常见设计模式总结\n\nhttps://blog.csdn.net/a745233700/article/details/120371090?spm=1001.2014.3001.5502\n\n[技术 (openai.com)](https://chat.openai.com/chat/eec202d8-3609-45c3-85f6-e8092966ef00)","tags":["资源"],"categories":["技术"]},{"title":"用户中心项目","url":"/2023/03/26/Java/用户中心/","content":"\n# 项目流程\n\n需求分析 => 设计 = > 技术选型 => 编码阶段（初始化、Demo、写代码[实现业务逻辑]、测试）=>提交 => 部署 => 发布\n\n# 需求分析\n\n作为其他系统的一个统一的用户管理中心，不用每一个系统都创建一个新的用户管理系统\n\n# 技术选型\n\n三件套 + ant design pro + react + umi + ant design(组件库)\n\n后端：\n\n- java\n- spring （依赖注入框架，帮助管理Java对象，集成一些其他的内容）\n- springmvc （web 框架， 提供接口访问，restful接口等能力）\n- mybatis（持久层框架，对jdbc的封装）\n- mybatis-plus（对mybatis的增强，不用写sql也能实现增删改查）\n  -  https://baomidou.com/\n- springboot （快速启动，）\n- mysql\n\n# 开发流程\n\n初始化\n\n数据库设计\n\n登录\n\n注册\n\n# 初始化前端\n\n**初始化项目**\n\n**引入组件**\n\n**框架介绍 / 瘦身 （在ant design pro 官网查看目录介绍）**\n\nhttps://pro.ant.design/zh-CN/\n\n## 问题\n\n**node:internal/crypto/hash:71 this[kHandle] = new _Hash(algorithm, xofLen)； 解决方法**\n\n​\t执行yarn start 或者 npm start时出现错误：\n​\tError: error:0308010C:digital envelope routines::unsupported\n\n​\t说明node版本太高，卸载node安装低版本node\n\n# 初始化后端\n\n## 数据库\n\nzip压缩包 解压，cmd打开bin\n\n**以前安装过MySQL：**\n\n```cmd\nnet stop MySQL // 停止服务\nsc delete MySQL // 删除服务\nmysqld remove // 移除服务\n```\n\n安装MySQL:\n\n```cmd\nmysqld --initialize --console // 初始化\nmysqld install // 安装myql服务\nnet start MySQL // 启动MySQL服务\nmysql -u root -p //登录\n```\n\n\n\n## 引入项目框架\n\nspring boot devtools 热部署\n\nlombok 自动生成get set方法\n\nSpring Configuration Processor 支持spring的configuration properties等注解，读取属性文件时有用\n\nmysql driver\n\nredis （用到后再加）\n\nspring web 给spring项目增加web访问能力\n\nmybatis 数据访问层的框架，操作数据库，对数据库进行增删改查\n\n## 添加功能\n\nuser的查询：\n\n- user对象\n- usermapper\n- 在启动类上加上包扫描 @MapperScan \n- 测试查询\n\n## 单元测试\n\nJunit **断言**\n\n认为这里的结果应该是一个认定的答案 如果不是就报错\n\n## 问题\n\n### **java版本与springboot版本对应的关系**\n\n| spring boot version | java version |\n| ------------------- | ------------ |\n| springboot2.x       | 8 or 9       |\n\n### **springboot配置mysql**\n\nmaven导入mysql依赖\n\n```xml\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n\n```yml\nspring:\n  # DataSource Config\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/user_center?useUnicode=true&useSSL=false&characterEncoding=utf-8\n    username: root\n    password: root\n```\n\n### **spring 的自动注入（注解开发）原理**\n\n@resource\n\n@autowrite\n\n# 数据库设计\n\n用户表： \n\nid 主键 \n\nusername 昵称\n\nuser_account 登录账号\n\navatar_url 头像\n\ngender 性别\n\nuser_password 密码\n\nphone 电话\n\nemail 邮箱\n\nuser_status 状态\n\nuser_role  用户角色 0 默认 1 管理员\n\n------\n\n下面三个字段在所有表中都应该有所记录\n\ncreate_time 创建时间 current_timestamp\n\nupdate_time 更新时间 current_timestamp on update current_timestamp\n\nis_delete 是否删除 （逻辑删除）\n\n**开闭原则**：对拓展开放，对修改关闭\n\ntruncate 清空表数据\n\n# 登录\n\n## 后端\n\n### 实现基本的数据库操作\n\n1. 模型user对象 => 和数据库关联\n\nmybatisX插件自动生成domain实体对象\n\ngenerateAllSetter自动生成所有对象属性设置\n\n```\nmybatis-plus 自动转驼峰的配置 注意\n```\n\n### 注册流程\n\n1. 用户输入账号密码，校验码（todo）\n\n2. 校验用户的账户、密码、校验密码是否合规\n\n   1. 账户不小于6位\n   2. 密码不小于8位\n   3. 账户不能重复\n   4. 账户不包含特殊字符\n   5. 密码和校验密码相同\n\n3. 对密码进行加密\n\n4. 向数据库插入用户数据\n\n   工具包：apache.common.lang3， 提供了很多重用的公共方法\n\n流程中注意对性能的处理，比如账户不能重复中会进行查库的操作可以放到最后进行\n\n单元测试\n\n```java\nString userAccount = \"sc\";\n        String userPassword = \"\";\n        String checkPassword = \"\";\n        long l = userService.userRegister(userAccount, userPassword, checkPassword);\n        Assertions.assertEquals(-1, l);\n        // 账户小于6位\n        userPassword = \"123456\";\n        checkPassword = \"1234567\";\n        l = userService.userRegister(userAccount, userPassword, checkPassword);\n        Assertions.assertEquals(-1, l);\n        // 密码不相等\n        userAccount = \"shangchun！\";\n        l = userService.userRegister(userAccount, userPassword, checkPassword);\n        Assertions.assertEquals(-1, l);\n        // 密码小于8位\n        userPassword = \"1234567\";\n        l = userService.userRegister(userAccount, userPassword, checkPassword);\n        Assertions.assertEquals(-1, l);\n        // 账号不符合规范\n        userPassword = \"12345678\";\n        checkPassword = \"12345678\";\n        l = userService.userRegister(userAccount, userPassword, checkPassword);\n        Assertions.assertEquals(-1, l);\n        userAccount = \"shangchun\";\n        l = userService.userRegister(userAccount, userPassword, checkPassword);\n        Assertions.assertEquals(-1, l);\n```\n\n### 登录流程\n\n接受参数：用户账户，密码\n\n请求类型：POST\n\n返回值：用户信息（**脱敏**）\n\n#### 逻辑\n\n1. 校验用户账户和密码是否合法\n\n2. 校验密码是否输入正确（之后可以做限流（看一下最近这个账户登录过多少次，如果登录次数太多，限制一下））\n\n   逻辑删除\n\n   ```yml\n   mybatis-plus:\n     global-config:\n       db-config:\n         logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n         logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n   ```\n\n   ```java\n   @Slf4j\n   // 这个注解可以使用log\n   ```\n\n3. 记录用户的登录态（session），存储到服务器上（用SpringBoot框架封装的服务器tomcat记录）\n\n4. 返回用户信息（脱敏）\n\n#### 如何知道是哪个用户登录 了\n\n（javaweb）\n\n1. 链接服务器端后，获得一个session状态返回给前端\n2. 登录成功后，得到登录成功的session，给session设置一些值（比如用户信息），返回给前端一个设置cookie的命令\n3. 前端设置cookie到浏览器\n4. 前端再次请求后端的时候，再请求头中带上cookie去请求\n5. 从session中取出基于该session存储的变量\n\n### 用户管理接口\n\n用户注册\n\n用户登录\n\n***鉴权***：对某些操作获取用户的权限值查看是否可以使用\n\n查询用户 (可以根据username查找)\n\n删除用户 (id)\n\n#### **测试**\n\nIDEA: Tools - > Http Client / 直接点击controller边上的按钮\n\nPostMan(没那么方便)\n\n## 前端\n\n修改 login 请求路径\n\n### 代理\n\n正向代理：替客户端发送请求\n\n反向代理：替服务器接受请求（代理服务器进行负载均衡）\n\numi 中对 request 请求的配置\n\n```ts\nexport const request: RequestConfig = {\n  // prefix: 'http://localhost:8080',\n};\n```\n\nant design pro 中的代理\n\n![image-20230228142352616](用户中心.assets\\image-20230228142352616.png)\n\n# 注册\n\n## 前端\n\n添加注册路由\n\n修改重定向\n\n> app.tsx 是全局初始和启动的入口，定义了整个项目中使用的公共数据（比如用户信息）\n>\n> access.ts 控制用户的访问权限\n\n前端后端都要做校验的原因：用户可以绕过前端直接向后端发起请求\n\n\n\n## 用户管理界面\n\nprocomponent：protable\n\n\n\n## 待优化 todo\n\n前端密码提示优化\n\n用户名重复，没有友好的提示\n\n用户注销\n\n优化查询接口\n\n# 获取用户登录态\n\n用户接口","tags":["Spring","加密","项目","Java","MyBatis","MySQL"],"categories":["技术"]},{"title":"Golang","url":"/2023/03/26/Golang/Golang/","content":"\n\n\n# 包、变量和函数\n\n每个 Go 程序都是由包构成的。\n\n程序从 `main` 包开始运行。\n\n\n\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n```\n\n此代码用圆括号组合了导入，这是“分组”形式的导入语句。\n\n当然你也可以编写多个导入语句，例如：\n\n```go\nimport \"fmt\"\nimport \"math\"\n```\n\n不过使用分组导入语句是更好的形式。\n\n\n\n在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。\n\n```go\nmath.Pi\n```\n\n## 函数\n\n函数可以没有参数或接受多个参数。\n\n```go\nfunc add(x int, y int) int {\n\treturn x + y\n}\n```\n\n当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n\n```go\nfunc add(x, y int) int {\n\treturn x + y\n}\n```\n\n函数可以返回任意数量的返回值。\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n```\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n没有参数的 `return` 语句返回已命名的返回值。也就是 `直接` 返回。\n\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n```\n\n## 变量\n\n`var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。\n\n`var` 语句可以出现在包或函数级别。\n\n```go\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.Println(i, c, python, java)\n}\n```\n\n变量声明可以包含初始值，每个变量对应一个。\n\n如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\n```go\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, \"no!\"\n\tfmt.Println(i, j, c, python, java)\n}\n```\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n- 数值类型为 `0`，\n- 布尔类型为 `false`，\n- 字符串为 `\"\"`（空字符串）。\n\n在函数中，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。\n\n函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。\n\n```go\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n\n\tfmt.Println(i, j, k, c, python, java)\n}\n```\n\n## 基本类型\n\nGo 的基本类型有\n\n```\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n`int`, `uint` 和 `uintptr` 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int` 类型\n\n 同导入语句一样，变量声明也可以“分组”成一个语法块\n\n```go\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n```\n\n## 类型转化\n\nGo 在不同类型的项之间赋值时需要显式转换\n\n表达式 `T(v)` 将值 `v` 转换为类型 `T`。\n\n一些关于数值的转换：\n\n```go\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者，更加简单的形式：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n## 常量\n\n常量的声明与变量类似，只不过是使用 `const` 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 `:=` 语法声明。\n\n# 流程控制语句：for、if、else、switch 和 defer\n\n## for\n\nGo 只有一种循环结构：`for` 循环。\n\n基本的 `for` 循环由三部分组成，它们用分号隔开：\n\n- 初始化语句：在第一次迭代前执行\n- 条件表达式：在每次迭代前求值\n- 后置语句：在每次迭代的结尾执行\n\n初始化语句通常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 `false`，循环迭代就会终止。\n\n```go\nfor i := 0; i < 10; i++ {\n\tsum += i\n}\n```\n\n初始化语句和后置语句可以去掉 此时分号也可以去掉  类似while\n\n```go\nfor sum<1000 {\n\tsum += sum\n}\n```\n\n省略条件则形成无限循环\n\n```go\nfor {\n}\n```\n\n## if\n\nGo 的 `if` 语句表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。\n\n```go\nif x < 0 {\n    return sqrt(-x) + \"i\"\n}\n```\n\n`if` 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 `if` 和 `else` 之内\n\n```go\nif v := math.Pow(x, n); v < lim {\n    return v + 1\n} else {\n    return v\n}\n```\n\n## switch\n\n`switch` 是编写一连串 `if - else` 语句的简便方法。它运行第一个值等于条件表达式的 case 语句\n\n Go 只运行选定的 case，而非之后所有的 case。Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句,除非以 `fallthrough` 语句结束，否则分支会自动终止。\n\n```go\nswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\\n\", os)\n}\t\n```\n\n没有条件的 switch 同 `switch true` 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\n```go\nswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n}\t\n```\n\n## defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n```go\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n//hello\n//world\n```\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n```go\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n```\n\n# 更多类型：struct、slice 和映射\n\n## 指针\n\nGo 拥有指针。指针保存了值的内存地址。\n\n类型 `*T` 是指向 `T` 类型值的指针。其零值为 `nil`。\n\n```\nvar p *int\n```\n\n`&` 操作符会生成一个指向其操作数的指针。\n\n```\ni := 42\np = &i\n```\n\n`*` 操作符表示指针指向的底层值。\n\n```\nfmt.Println(*p) // 通过指针 p 读取 i\n*p = 21         // 通过指针 p 设置 i\n```\n\n这也就是通常所说的“间接引用”或“重定向”。\n\nGo 没有指针运算。\n\n```go\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通过指针读取 i 的值\n\t*p = 21         // 通过指针设置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 指向 j\n\t*p = *p / 37   // 通过指针对 j 进行除法运算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n## 结构体\n\n一个结构体（`struct`）就是一组字段（field）。\n\n结构体字段使用点号来访问。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n    v := Vertex{1, 2}\n    v.X = 4\n\tfmt.Println(v)\n}\n```\n\n结构体字段可以通过结构体指针来访问。\n\n如果我们有一个指向结构体的指针 `p`，那么可以通过 `(*p).X` 来访问其字段 `X`。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 `p.X` 就可以。\n\n```go\nfunc main() {\n\tv := Vertex{1, 2}\n\tp := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n}\n```\n\n结构体文法通过直接列出字段的值来新分配一个结构体。\n\n使用 `Name:` 语法可以仅列出部分字段。（字段名的顺序无关。）\n\n特殊的前缀 `&` 返回一个指向结构体的指针。\n\n```go\nvar (\n\tv1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体\n\tv2 = Vertex{X: 1}  // Y:0 被隐式地赋予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）\n)\n```\n\n## 数组\n\n类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组。\n\n表达式\n\n```\nvar a [10]int\n```\n\n会将变量 `a` 声明为拥有 10 个整数的数组。\n\n数组的长度是其类型的一部分，因此数组不能改变大小。\n\n\n\n## 切片\n\n每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n\n类型 `[]T` 表示一个元素类型为 `T` 的切片。\n\n切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：\n\n```\na[low : high]\n```\n\n它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n\n以下表达式创建了一个切片，它包含 `a` 中下标从 1 到 3 的元素：\n\n```\na[1:4]\n```\n\n切片并不存储任何数据，它只是描述了底层数组中的一段。\n\n更改切片的元素会修改其底层数组中对应的元素。\n\n与它共享底层数组的切片都会观测到这些修改。\n\n\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：\n\n```\n[3]bool{true, true, false}\n```\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n```\n[]bool{true, true, false}\n```\n\n\n\n在进行切片时，你可以利用它的默认行为来忽略上下界。\n\n切片下界的默认值为 `0`，上界则是该切片的长度。\n\n对于数组\n\n```\nvar a [10]int\n```\n\n来说，以下切片是等价的：\n\n```\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n切片拥有 **长度** 和 **容量**。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从切片的第一个元素开始数，到其底层数组元素末尾的个数。\n\n切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。\n\n\n\n切片的零值是 `nil`。\n\nnil 切片的长度和容量为 0 且没有底层数组。\n\n\n\n**用 make 创建切片**\n\n切片可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。\n\n`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\n```\na := make([]int, 5)  // len(a)=5\n```\n\n要指定它的容量，需向 `make` 传入第三个参数：\n\n```\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n```\n\n\n\n为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 `append` 函数。内建函数的[文档](https://go-zh.org/pkg/builtin/#append)对此函数有详细的介绍。\n\n```\nfunc append(s []T, vs ...T) []T\n```\n\n`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。\n\n`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。\n\n当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n\n**文章 [Go 切片：用法和本质](https://blog.go-zh.org/go-slices-usage-and-internals)。**\n\n## Range\n\n`for` 循环的 `range` 形式可遍历切片或映射。\n\n当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n\n```go\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n```\n\n可以将下标或值赋予 `_` 来忽略它。\n\n```\nfor i, _ := range pow\nfor _, value := range pow\n```\n\n若只需要索引，忽略第二个变量即可。\n\n```\nfor i := range pow\n```\n\n## 练习：切片\n\n实现 `Pic`。它应当返回一个长度为 `dy` 的切片，其中每个元素是一个长度为 `dx`，元素类型为 `uint8` 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。\n\n图像的选择由你来定。几个有趣的函数包括 `(x+y)/2`, `x*y`, `x^y`, `x*log(y)` 和 `x%(y+1)`。\n\n（提示：需要使用循环来分配 `[][]uint8` 中的每个 `[]uint8`；请使用 `uint8(intValue)` 在类型之间转换；你可能会用到 `math` 包中的函数。）\n\n```go\nimport \"golang.org/x/tour/pic\"\n\nfunc Pic(dx, dy int) [][]uint8 {\n\tdySlice := [][]uint8{}\n\tfor i:=0; i<dy; i++ {\n\t\tdxSlice := make([]uint8,dx)\n\t\tfor j:=0; j<dx; j++ {\n\t\t\tdxSlice[j] = uint8((i%(j+1)))\n\t\t}\n\t\tdySlice = append(dySlice, dxSlice)\n\t}\n\treturn dySlice\n}\n\nfunc main() {\n\tpic.Show(Pic)\n}\n```\n\n## 映射\n\n映射将键映射到值。\n\n映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。\n\n`make` 函数会返回给定类型的映射，并将其初始化备用。\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m map[string]Vertex\n\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm[\"Bell Labs\"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m[\"Bell Labs\"])\n}\n\n```\n\n在映射 `m` 中插入或修改元素：\n\n```\nm[key] = elem\n```\n\n获取元素：\n\n```\nelem = m[key]\n```\n\n删除元素：\n\n```\ndelete(m, key)\n```\n\n通过双赋值检测某个键是否存在：\n\n```\nelem, ok = m[key]\n```\n\n若 `key` 在 `m` 中，`ok` 为 `true` ；否则，`ok` 为 `false`。\n\n若 `key` 不在映射中，那么 `elem` 是该映射元素类型的零值。\n\n同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。\n\n## 练习：映射\n\n实现 `WordCount`。它应当返回一个映射，其中包含字符串 `s` 中每个“单词”的个数。函数 `wc.Test` 会对此函数执行一系列测试用例，并输出成功还是失败。\n\n```go\n\nfunc WordCount(s string) map[string]int {\n\tstrs := strings.Fields(s)\n\tm := make(map[string]int)\n\tfor _, v := range strs {\n\t\telem := m[v] + 1\n\t\tm[v] = elem\n\t}\n\treturn m\n}\n\nfunc main() {\n\twc.Test(WordCount)\n}\n```\n\n![image-20230317085357965](H:\\Users\\zx065\\Desktop\\Java\\Untitled.assets\\image-20230317085357965.png)\n\n## 函数的闭包\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。\n\n```go\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n```\n\n## 练习：斐波纳契闭包\n\n让我们用函数做些好玩的事情。\n\n实现一个 `fibonacci` 函数，它返回一个函数（闭包），该闭包返回一个[斐波纳契数列](https://zh.wikipedia.org/wiki/斐波那契数列) `(0, 1, 1, 2, 3, 5, ...)`。\n\n```go\nfunc fibonacci() func() int {\n\tfirst := 0\n\tsecond := 1\n\treturn func() int {\n\t\tback := first\n\t\tfirst, second = second, first + second\n\t\treturn back\n\t\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n```\n\n# 方法和接口\n\n## 方法\n\nGo 没有类。不过你可以为结构体类型定义方法。\n\n方法就是一类带特殊的 **接收者** 参数的函数。\n\n方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。\n\n在此例中，`Abs` 方法拥有一个名为 `v`，类型为 `Vertex` 的接收者。\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n\n```\n\n也可以为非结构体类型声明方法。\n\n在此例中，我们看到了一个带 `Abs` 方法的数值类型 `MyFloat`。\n\n只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 `int` 之类的内建类型）的接收者声明方法。\n\n（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）\n\n```go\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n```\n\n## 指针接收者\n\n你可以为指针接收者声明方法。\n\n这意味着对于某类型 `T`，接收者的类型可以用 `*T` 的文法。（此外，`T` 不能是像 `*int` 这样的指针。）\n\n例如，这里为 `*Vertex` 定义了 `Scale` 方法。\n\n指针接收者的方法可以修改接收者指向的值（就像 `Scale` 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。\n\n移除 `Scale` 函数声明中的 `*`，输出结果为5。\n\n若使用值接收者，那么 `Scale` 方法会对原始 `Vertex` 值的副本进行操作。（对于函数的其它参数也是如此。）`Scale` 方法必须用指针接受者来更改 `main` 函数中声明的 `Vertex` 的值。\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10)\n\tfmt.Println(v.Abs())\n}\n```\n\n## 方法与指针重定向\n\n带指针参数的函数必须接受一个指针：\n\n```\nvar v Vertex\nScaleFunc(v, 5)  // 编译错误！\nScaleFunc(&v, 5) // OK\n```\n\n而以指针为接收者的方法被调用时，接收者既能为值又能为指针：\n\n```\nvar v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n```\n\n对于语句 `v.Scale(5)`，即便 `v` 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 `Scale` 方法有一个指针接收者，为方便起见，Go 会将语句 `v.Scale(5)` 解释为 `(&v).Scale(5)`。\n\n同样的事情也发生在相反的方向。\n\n接受一个值作为参数的函数必须接受一个指定类型的值：\n\n```\nvar v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // 编译错误！\n```\n\n而以值为接收者的方法被调用时，接收者既能为值又能为指针：\n\n```\nvar v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n```\n\n这种情况下，方法调用 `p.Abs()` 会被解释为 `(*p).Abs()`。\n\n使用指针接收者的原因有二：\n\n首先，方法能够修改其接收者指向的值。\n\n其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。\n\n在本例中，`Scale` 和 `Abs` 接收者的类型为 `*Vertex`，即便 `Abs` 并不需要修改其接收者。\n\n通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。\n\n## 接口\n\n**接口类型** 是由一组方法签名定义的集合。\n\n接口类型的变量可以保存任何实现了这些方法的值\n\n```go\ntype Abser interface {\n\tAbs() float64\n}\n\ntype MyFloat float64\n// MyFloat实现\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype Vertex struct {\n\tX, Y float64\n}\n// *Vertex 实现\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n```\n\n## 接口与隐式实现\n\n类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。\n\n隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。\n\n```go\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\n// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。\nfunc (t T) M() {\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I = T{\"hello\"}\n\ti.M()\n}\n```\n\n## 类型断言\n\n**类型断言** 提供了访问接口值底层具体值的方式。\n\n```\nt := i.(T)\n```\n\n该语句断言接口值 `i` 保存了具体类型 `T`，并将其底层类型为 `T` 的值赋予变量 `t`。\n\n若 `i` 并未保存 `T` 类型的值，该语句就会触发一个恐慌。\n\n为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n\n```\nt, ok := i.(T)\n```\n\n若 `i` 保存了一个 `T`，那么 `t` 将会是其底层值，而 `ok` 为 `true`。\n\n否则，`ok` 将为 `false` 而 `t` 将为 `T` 类型的零值，程序并不会产生恐慌。\n\n请注意这种语法和读取一个映射时的相同之处。\n\n## Stringer\n\n[`fmt`](https://go-zh.org/pkg/fmt/) 包中定义的 [`Stringer`](https://go-zh.org/pkg/fmt/#Stringer) 是最普遍的接口之一。类似java object中的toString()\n\n```\ntype Stringer interface {\n    String() string\n}\n```\n\n`Stringer` 是一个可以用字符串描述自己的类型。`fmt` 包（还有很多包）都通过此接口来打印值。\n\n```go\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf(\"%v (%v years)\", p.Name, p.Age)\n}\n\nfunc main() {\n\ta := Person{\"Arthur Dent\", 42}\n\tz := Person{\"Zaphod Beeblebrox\", 9001}\n\tfmt.Println(a, z)\n}\n\n```\n\n## 错误\n\nGo 程序使用 `error` 值来表示错误状态。\n\n与 `fmt.Stringer` 类似，`error` 类型是一个内建接口：\n\n```\ntype error interface {\n    Error() string\n}\n```\n\n（与 `fmt.Stringer` 类似，`fmt` 包在打印值时也会满足 `error`。）\n\n通常函数会返回一个 `error` 值，调用的它的代码应当判断这个错误是否等于 `nil` 来进行错误处理。\n\n```\ni, err := strconv.Atoi(\"42\")\nif err != nil {\n    fmt.Printf(\"couldn't convert number: %v\\n\", err)\n    return\n}\nfmt.Println(\"Converted integer:\", i)\n```\n\n`error` 为 nil 时表示成功；非 nil 的 `error` 表示失败。\n\n##  练习：错误\n\n从[之前的练习](https://tour.go-zh.org/flowcontrol/8)中复制 `Sqrt` 函数，修改它使其返回 `error` 值。\n\n`Sqrt` 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。\n\n创建一个新的类型\n\n```\ntype ErrNegativeSqrt float64\n```\n\n并为其实现\n\n```\nfunc (e ErrNegativeSqrt) Error() string\n```\n\n方法使其拥有 `error` 值，通过 `ErrNegativeSqrt(-2).Error()` 调用该方法应返回 `\"cannot Sqrt negative number: -2\"`。\n\n**注意:** 在 `Error` 方法内调用 `fmt.Sprint(e)` 会让程序陷入死循环。可以通过先转换 `e` 来避免这个问题：`fmt.Sprint(float64(e))`。这是为什么呢？\n\n修改 `Sqrt` 函数，使其接受一个负数时，返回 `ErrNegativeSqrt` 值。\n\n\n\n```go\ntype ErrNegativeSqrt float64\n\nfunc (e ErrNegativeSqrt) Error() string {\n\treturn fmt.Sprintf(\"cannot Sqrt negative number: %v\",float64(e))\n}\n\n\nfunc Sqrt(x float64) (float64, error) {\n\tif x<0 {\n\t\treturn x, ErrNegativeSqrt(x)\n\t}\n\treturn 0, nil\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(2))\n\tfmt.Println(Sqrt(-2))\n}\n\n```\n\n\n\n## Reader\n\n`io` 包指定了 `io.Reader` 接口，它表示从数据流的末尾进行读取。\n\nGo 标准库包含了该接口的[许多实现](https://go-zh.org/search?q=Read#Global)，包括文件、网络连接、压缩和加密等等。\n\n`io.Reader` 接口有一个 `Read` 方法：\n\n```\nfunc (T) Read(b []byte) (n int, err error)\n```\n\n`Read` 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 `io.EOF` 错误。\n\n示例代码创建了一个 [`strings.Reader`](https://go-zh.org/pkg/strings/#Reader) 并以每次 8 字节的速度读取它的输出。\n\n## 练习：Reader\n\n实现一个 `Reader` 类型，它产生一个 ASCII 字符 `'A'` 的无限流。\n\n```go\ntype MyReader struct{}\n\n// TODO: 给 MyReader 添加一个 Read([]byte) (int, error) 方法\n\nfunc (reader MyReader) Read(p []byte) (int, error) {\n\tfor i:=0; i < len(p); i++ {\n\t\tp[i] = 'A'\n\t}\n\treturn len(p), nil\n}\n\nfunc main() {\n\treader.Validate(MyReader{})\n}\n\n```\n\n##  练习：图像\n\n还记得之前编写的[图片生成器](https://tour.go-zh.org/moretypes/18) 吗？我们再来编写另外一个，不过这次它将会返回一个 `image.Image` 的实现而非一个数据切片。\n\n定义你自己的 `Image` 类型，实现[必要的方法](https://go-zh.org/pkg/image/#Image)并调用 `pic.ShowImage`。\n\n`Bounds` 应当返回一个 `image.Rectangle` ，例如 `image.Rect(0, 0, w, h)`。\n\n`ColorModel` 应当返回 `color.RGBAModel`。\n\n`At` 应当返回一个颜色。上一个图片生成器的值 `v` 对应于此次的 `color.RGBA{v, v, 255, 255}`。\n\n```go\ntype Image struct{}\n\nfunc (image Image) ColorModel() color.Model {\n\treturn color.RGBAModel\n}\n\nfunc (i Image) Bounds() image.Rectangle {\n\treturn image.Rect(0, 0, 200, 200)\n}\n\nfunc (image Image) At(x, y int) color.Color {\n\treturn color.RGBA{uint8(x),uint8(y),uint8(255),uint8(255)}\n}\n\nfunc main() {\n\tm := Image{}\n\tpic.ShowImage(m)\n}\n\n```\n\n# **并发**\n\n## Go 程\n\nGo 程（goroutine）是由 Go 运行时管理的轻量级线程。\n\n```\ngo f(x, y, z)\n```\n\n会启动一个新的 Go 程并执行\n\n```\nf(x, y, z)\n```\n\n`f`, `x`, `y` 和 `z` 的求值发生在当前的 Go 程中，而 `f` 的执行发生在新的 Go 程中。\n\nGo 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。\n\n```go\n\nfunc say(s string) {\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say(\"world\")\n\tsay(\"hello\")\n}\n\n```\n\n## 信道\n\n信道是带有类型的管道，你可以通过它用信道操作符 `<-` 来发送或者接收值。\n\n```\nch <- v    // 将 v 发送至信道 ch。\nv := <-ch  // 从 ch 接收值并赋予 v。\n```\n\n（“箭头”就是数据流的方向。）\n\n和映射与切片一样，信道在使用前必须创建：\n\n```\nch := make(chan int)\n```\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。\n\n以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。\n\n```go\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum // 将和送入 c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := <-c, <-c // 从 c 中接收\n\n\tfmt.Println(x, y, x+y)\n}\n```\n\n## range 和 close\n\n发送者可通过 `close` 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完\n\n```\nv, ok := <-ch\n```\n\n之后 `ok` 会被设置为 `false`。\n\n循环 `for i := range c` 会不断从信道接收值，直到它被关闭。\n\n*注意：* 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。\n\n*还要注意：* 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range` 循环。\n\n```go\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n\n```\n\n## 练习：等价二叉查找树\n\n**1.** 实现 `Walk` 函数。\n\n**2.** 测试 `Walk` 函数。\n\n函数 `tree.New(k)` 用于构造一个随机结构的已排序二叉查找树，它保存了值 `k`, `2k`, `3k`, ..., `10k`。\n\n创建一个新的信道 `ch` 并且对其进行步进：\n\n```\ngo Walk(tree.New(1), ch)\n```\n\n然后从信道中读取并打印 10 个值。应当是数字 `1, 2, 3, ..., 10`。\n\n**3.** 用 `Walk` 实现 `Same` 函数来检测 `t1` 和 `t2` 是否存储了相同的值。\n\n**4.** 测试 `Same` 函数。\n\n`Same(tree.New(1), tree.New(1))` 应当返回 `true`，而 `Same(tree.New(1), tree.New(2))` 应当返回 `false`。\n\n`Tree` 的文档可在[这里](https://godoc.org/golang.org/x/tour/tree#Tree)找到。\n\n```go\n// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。\nfunc Walk(t *tree.Tree, ch chan int) {\n\tvisit(t, ch)\n\tclose(ch)\n}\n\nfunc visit(t *tree.Tree, ch chan int){\n\tif t==nil {\n\t\treturn\n\t}\n\tch <- t.Value\n\tright := t.Right\n\tvisit(right, ch)\n\tleft := t.Left\n\tvisit(left, ch)\n\n}\n\n// Same 检测树 t1 和 t2 是否含有相同的值。\nfunc Same(t1, t2 *tree.Tree) bool {\n\t\n\ti := 0\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\t\n\tgo Walk(t1, ch1)\n\tgo Walk(t2, ch2)\n\t\n\t// 异或两次同一个值之后会为原值\n\tfor j := range ch1 {\n\t\tfmt.Println(j)\n\t\ti ^= j\n\t}\n\tfor j := range ch2 {\n\t\tfmt.Println(j)\n\t\ti ^= j\n\t}\n\treturn i == 0;\n}\n\nfunc main() {\n\tfmt.Println(Same(tree.New(1), tree.New(1)))\n\t\n}\n```\n\n## 练习：Web 爬虫\n\n在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。\n\n修改 `Crawl` 函数来并行地抓取 URL，并且保证不重复。\n\n*提示*：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！\n\n\n\n`sync.WaitGroup` 是 Go 语言标准库中的一个并发原语，它可以用于协调和同步多个 Goroutine 的执行，以确保在所有 Goroutine 执行完毕之后，程序才能继续往下执行。\n\n在使用 `sync.WaitGroup` 时，首先需要通过 `Add` 方法设置要等待的 Goroutine 的数量，然后在每个 Goroutine 执行完毕之后，都需要调用 `Done` 方法，以通知 `WaitGroup` 该 Goroutine 已经执行完毕。最后，通过调用 `Wait` 方法等待所有 Goroutine 执行完毕，程序才会继续往下执行。\n\n具体来说，可以通过以下的步骤来使用 `sync.WaitGroup`：\n\n1. 创建一个 `sync.WaitGroup` 对象。\n2. 在要执行的 Goroutine 前调用 `Add` 方法，将要执行的 Goroutine 的数量加 1。\n3. 在每个 Goroutine 执行完毕后调用 `Done` 方法，将要执行的 Goroutine 的数量减 1。\n4. 在主 Goroutine 中调用 `Wait` 方法，等待所有 Goroutine 执行完毕。\n\n示例代码如下：\n\n```\ngoCopy codepackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    fmt.Printf(\"Worker %d starting\\n\", id)\n\n    // 模拟一些工作\n    for i := 0; i < 1000000000; i++ {\n\n    }\n\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    // 创建 3 个 Goroutine\n    for i := 1; i <= 3; i++ {\n        wg.Add(1)\n        go worker(i, &wg)\n    }\n\n    // 等待所有 Goroutine 执行完毕\n    wg.Wait()\n\n    fmt.Println(\"All workers done\")\n}\n```\n\n在上面的示例代码中，我们创建了 3 个 Goroutine，并且使用 `Add` 方法将要执行的 Goroutine 的数量加 1。在每个 Goroutine 执行完毕后，我们使用 `Done` 方法将要执行的 Goroutine 的数量减 1。最后，我们在主 Goroutine 中使用 `Wait` 方法等待所有 Goroutine 执行完毕。\n\n```go\ntype Fetcher interface {\n\t// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。\n\tFetch(url string) (body string, urls []string, err error)\n}\n\ntype urlRecord struct {\n\tv   map[string]int\n\tmux sync.Mutex\n\twg  sync.WaitGroup\n}\n\nvar m = urlRecord{v: make(map[string]int)}\n\n// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。\nfunc Crawl(url string, depth int, fetcher Fetcher) {\n\t// TODO: 并行的抓取 URL。\n\t// TODO: 不重复抓取页面。\n\t// 下面并没有实现上面两种情况：\n\tdefer m.wg.Done()\n\tif depth <= 0 {\n\t\treturn\n\t}\n\t\n\n\tm.mux.Lock()\n\tm.v[url]++\n\tm.mux.Unlock()\n\n\tbody, urls, err := fetcher.Fetch(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Printf(\"found: %s %q\\n\", url, body)\n\tfor _, u := range urls {\n\t\tm.mux.Lock()\n\t\tif _, ok := m.v[u]; !ok {\n\t\t\tm.wg.Add(1)\n\t\t\tgo Crawl(u, depth-1, fetcher)\n\t\t}\n\t\tm.mux.Unlock()\n\t}\n\treturn\n}\n\nfunc main() {\n\t\n\tm.wg.Add(1)\n\tgo Crawl(\"https://golang.org/\", 4, fetcher)\n\tm.wg.Wait()\n}\n\n// fakeFetcher 是返回若干结果的 Fetcher。\ntype fakeFetcher map[string]*fakeResult\n\ntype fakeResult struct {\n\tbody string\n\turls []string\n}\n\nfunc (f fakeFetcher) Fetch(url string) (string, []string, error) {\n\tif res, ok := f[url]; ok {\n\t\treturn res.body, res.urls, nil\n\t}\n\treturn \"\", nil, fmt.Errorf(\"not found: %s\", url)\n}\n\n// fetcher 是填充后的 fakeFetcher。\nvar fetcher = fakeFetcher{\n\t\"https://golang.org/\": &fakeResult{\n\t\t\"The Go Programming Language\",\n\t\t[]string{\n\t\t\t\"https://golang.org/pkg/\",\n\t\t\t\"https://golang.org/cmd/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/\": &fakeResult{\n\t\t\"Packages\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/cmd/\",\n\t\t\t\"https://golang.org/pkg/fmt/\",\n\t\t\t\"https://golang.org/pkg/os/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/fmt/\": &fakeResult{\n\t\t\"Package fmt\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/pkg/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/os/\": &fakeResult{\n\t\t\"Package os\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/pkg/\",\n\t\t},\n\t},\n}\n```\n\n","tags":["Golang"],"categories":["技术"]},{"title":"Spring编程思想","url":"/2023/03/26/Java/Spring/","content":"\n\n\n# Spring IOC\n\n## 概念\n\nIOC （inversion of control）控制反转，是一种编程思想，对面对对象的补充，通过将对象的创建，组装，管理反转在框架中进行，实现低耦合和可重用性\n\n## 流程\n\n创建工厂\n\n读取配置文件\n\n通过配置文件创建实例\n\n## 实现\n\n1. 三层架构 Dao - Service - Controller\n\n```java\npublic class HelloDaoImpl implements HelloDao {\n    @Override\n    public List<String> findAll() {\n        return Arrays.asList(\"1\", \"2\", \"3\");\n    }\n}\n```\n\n```java\npublic class HelloServiceImpl implements HelloService {\n\n    private HelloDao helloDao = new HelloDaoImpl();\n     \n\n    @Override\n    public List<String> findAll() {\n        return helloDao.findAll();\n    }\n}\n\n```\n\n```java\n@WebServlet(\"/hello\")\npublic class HelloServlet extends HttpServlet {\n\n    HelloService helloService = new HelloServiceImpl();\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.getWriter().write(\"spring\"  + helloService.findAll());\n    }\n}\n```\n\n2. 当需求发生改变时，代码需要更改，要重写接口代码\n\n   **解决：** 使用静态工厂创建特定的类，不用在Service中写死代码\n\n   ```java\n   public class BeanFactory {\n       public static HelloDao getDao(){\n       \treturn new HelloDaoImpl();\n       }\n   }\n   ```\n\n   ```java\n   private HelloDao helloDao = BeanFactory.getDao();\n   ```\n\n   **问题：**需求发生改变时 仍然需要修改代码\n\n   解决：使用反射从配置文件中获取具体的类\n\n   1. 定义配置文件\n\n   2. 程序中读取配置文件\n\n      ```java\n            public class BeanFactory {\n                /**\n                 * 使用工厂创建特定的类，不用写死在Service中\n                 *\n                 * version1  public static HelloDao getDao(){\n                 *         return new HelloDaoImpl();\n                 *     }\n                 * @return\n                 */\n                public static Object getDao(){\n                    String helloDao = properties.getProperty(\"helloDao\");\n                    // 利用反射创建对象\n                    // 通过更改配置文件就可以解决代码不能切换的问题\n                    try {\n                        Class<?> aClass = Class.forName(helloDao);\n                        return aClass.getConstructor( null).newInstance();\n                    } catch (ClassNotFoundException | InvocationTargetException | InstantiationException | IllegalAccessException |\n                             NoSuchMethodException e) {\n                        e.printStackTrace();\n                        return null;\n                    }\n                }\n            \n                /**\n                 * 读取配置文件\n                 */\n                private static Properties properties;\n            \n                static {\n                    properties = new Properties();\n                    try {\n                        properties.load(BeanFactory.class.getClassLoader().getResourceAsStream(\"application.properties\"));\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n      ```\n\n   3. 获取\n\n      之后使用外部配置修改解决代码切换的问题\n\n      \n\n**创建的对象不是单例**\n\n\n\n重复使用对象会出现使用很多个实例的问题\n\n解决：使用 Map 存放创建的对象，同时加锁保证线程安全\n\n```java\npublic static Object getDao(String beanName){\n        if (!cache.containsKey(beanName)){\n            synchronized (BeanFactory.class){\n                if (!cache.containsKey(beanName)){\n                    // 利用反射创建对象\n                    // 通过更改配置文件就可以解决代码不能切换的问题\n                    try {\n                        String helloDao = properties.getProperty(beanName);\n                        Class<?> aClass = Class.forName(helloDao);\n                        Object o = aClass.getConstructor(null).newInstance();\n                        cache.put(beanName, o);\n                    } catch (ClassNotFoundException | InvocationTargetException | InstantiationException | IllegalAccessException |\n                             NoSuchMethodException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return cache.get(beanName);\n    }\n```\n\n\n\n放弃创造对象的权限，将权限交给 BeanFactory\n\n这种由别人或者对象控制的思想就是 **IOC 控制反转**\n\n\n\n# 基于注解的 IOC\n\n通过配置文件获取还是很麻烦，根据注解创建 Bean 实例，通过注解获取到 Bean 实例更为方便\n\n## 流程\n\n![img](https://article-images.zsxq.com/Fr5lKUGA910wfJcrKhb7wMitvUKy)\n\n1. 扫描包\n\n2. 获取包下添加了注解的类，获取其中的组件 Class 和 BeanName 封装成 BeanDefination 存入集合，这个集合就是 IOC 自动装载的原材料\n\n3. 通过反射机制创建对象，将动态创建的对象以 Map 的形式存入缓存\n\n4. 通过 BeanName 取出对应的 Bean, 使用反射执行方法\n\n   \n\n## 实现\n\n```java\n/**\n * 容器\n */\npublic class MyAnnotationConfigApplicationContext {\n\n    private HashMap<String, Object> ioc =  new HashMap<>();\n\n    public Object getBean(String beanName) {\n        return ioc.get(beanName);\n    }\n\n    /**\n     *\n     * @param pack\n     */\n    public MyAnnotationConfigApplicationContext(String pack) {\n        //1. 扫描包\n        //2. 获取包下添加了注解的类，获取其中的组件 Class 和 BeanName 封装成 BeanDefination 存入集合，这个集合就是 IOC 自动装载的原材料\n        Set<BeanDefinition> beanDefinition = findBeanDefinition(pack);\n        //3. 通过反射机制创建对象，将动态创建的对象以 Map 的形式存入缓存\n        createObject(beanDefinition);\n        // 自动装载\n\t\tautowireObject(beanDefinition);\n    }\n\n    public void autowireObject(Set<BeanDefinition> beanDefinitions) {\n        //获取注入的集合\n        Iterator<BeanDefinition> iterator = beanDefinitions.iterator();\n        while (iterator.hasNext()) {\n            //拿到bean 信息\n            BeanDefinition beanDefinition = iterator.next();\n            //获取当前需要自动装配的对象\n            Class clazz = beanDefinition.getBeanClass();\n            //拿到全部属性\n            Field[] declaredFields = clazz.getDeclaredFields();\n            for (Field field : declaredFields) {\n                Autowired annotation = field.getAnnotation(Autowired.class);\n                if (annotation != null) {\n                    Qualifer qualifer = field.getAnnotation(Qualifer.class);\n                    if (qualifer != null) {\n                        try {\n                            // 根据字段的名字获取\n                            String beanName = qualifer.value();\n                            Object bean = getBean(beanName);\n                            String fieldName = field.getName();\n                            String mothedName = \"set\" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);\n                            Method method = clazz.getMethod(mothedName, field.getType());\n                            Object object = getBean(beanDefinition.getBeanName());\n                            System.out.println(bean);\n                            method.invoke(object, bean);\n                        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                        //byType\n                    }\n                }\n            }\n        }\n    }\n\n    public void createObject(Set<BeanDefinition> beanDefinitions) {\n        Iterator<BeanDefinition> iterator = beanDefinitions.iterator();\n        while (iterator.hasNext()) {\n            BeanDefinition beanDefinition = iterator.next();\n            Class beanClass = beanDefinition.getBeanClass();\n            String beanName = beanDefinition.getBeanName();\n            try {\n                Object o = beanClass.getConstructor().newInstance();\n                // 属性字段 设置值\n                Field[] declaredFields = beanClass.getDeclaredFields();\n                for (Field declaredField : declaredFields) {\n                    Value valueAnnotation = declaredField.getAnnotation(Value.class);\n                    if (valueAnnotation != null) {\n                        String value = valueAnnotation.value();\n                        String fieldName = declaredField.getName();\n                        // set方法\n                        String methodName = \"set\" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);\n                        Method method = beanClass.getMethod(methodName, declaredField.getType());\n                        //数据类型转换\n                        Object val = null;\n                        //可能会有很多类型 篇幅过长\n                        switch (declaredField.getType().getName()) {\n                            case \"java.lang.Integer\":\n                                val = Integer.parseInt(value);\n                                break;\n                            case \"java.lang.String\":\n                                val = value;\n                                break;\n                            case \"java.lang.Float\":\n                                val = Float.parseFloat(value);\n                                break;\n                        }\n                        // 执行\n                        method.invoke(o, val);\n                    }\n                }\n                ioc.put(beanName, o);\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException |\n                     NoSuchMethodException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 扫描包中符合条件的类\n     * @param pack\n     * @return\n     */\n    public Set<BeanDefinition> findBeanDefinition(String pack){\n        // 1. 获取包下所有类\n        HashSet<BeanDefinition> beanDefinitions = new HashSet<>();\n        Set<Class> classes = getClasses(pack);\n        Iterator<Class> iterator = classes.iterator();\n        // 2. 遍历类，找到添加了注解的类\n        while (iterator.hasNext()) {\n            Class clazz = iterator.next();\n            Component annotation = (Component) clazz.getAnnotation(Component.class);\n            if (annotation != null ) {\n                // 获取Component的值\n                String beanName = annotation.value();\n                if (\"\".equals(beanName)) {\n                    // 获取类名\n                    beanName = clazz.getSimpleName();\n                }\n                BeanDefinition beanDefinition = new BeanDefinition(clazz, beanName);\n                beanDefinitions.add(beanDefinition);\n            }\n        }\n        // 3. 将这些类封装成BeanDefinition装载到集合中\n        return beanDefinitions;\n    }\n\n    /**\n     * get classes\n     * @param pack\n     * @return\n     */\n    public Set<Class> getClasses(String pack){\n        Set<Class> classes = new LinkedHashSet<>();\n        // get package name and replace to url\n        String packageName = pack;\n        String packageDirName = packageName.replace(\".\", \"/\");\n        Enumeration<URL> dirs;\n        try {\n            dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);\n            while (dirs.hasMoreElements()) {\n                // get next element\n                URL url = dirs.nextElement();\n                String protocol = url.getProtocol();\n                // if it is saved at server like a file\n                if (\"file\".equals(protocol)) {\n                    String decode = URLDecoder.decode(url.getFile(), \"UTF-8\");\n                    findClassesInPackageByFile(packageName, decode, true, classes);\n                } else if (\"jar\".equals(protocol)) {\n                    // 如果是jar包文件\n                    // 定义一个JarFile\n                    System.out.println(\"jar类型的扫描\");\n                    JarFile jar;\n                    try {\n                        // 获取jar\n                        jar = ((JarURLConnection) url.openConnection()).getJarFile();\n                        // 从此jar包 得到一个枚举类\n                        Enumeration<JarEntry> entries = jar.entries();\n                        findClassesInPackageByJar(packageName, entries, packageDirName, true, classes);\n                    } catch (IOException e) {\n                        // log.error(\"在扫描用户定义视图时从jar包获取文件出错\");\n                        e.printStackTrace();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return classes;\n    }\n\n    private static void findClassesInPackageByFile(String packageName, String packagePath, final boolean recursive, Set<Class> classes){\n        File dir = new File(packagePath);\n\n        if(!dir.exists() || !dir.isDirectory()){\n            return;\n        }\n        // 获取目录下的目录和以.class结尾的文件\n        File[] dirFiles = dir.listFiles(file -> (recursive && file.isDirectory()) || file.getName().endsWith(\".class\"));\n        for (File dirFile : dirFiles) {\n            if(dirFile.isDirectory()) {\n                // 目录继续往里找\n                findClassesInPackageByFile(packageName + \".\" + dirFile.getName(), dirFile.getAbsolutePath(), recursive, classes);\n            } else {\n                // 去除.class\n                String classFileName = dirFile.getName().substring(0, dirFile.getName().length() - 6);\n                // 添加进class\n                try {\n                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + \".\" + classFileName));\n                } catch (ClassNotFoundException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static void findClassesInPackageByJar(String packageName, Enumeration<JarEntry> entries, String packageDirName, final boolean recursive, Set<Class> classes) {\n        // 同样的进行循环迭代\n        while (entries.hasMoreElements()) {\n            // 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件\n            JarEntry entry = entries.nextElement();\n            String name = entry.getName();\n            // 如果是以/开头的\n            if (name.charAt(0) == '/') {\n                // 获取后面的字符串\n                name = name.substring(1);\n            }\n            // 如果前半部分和定义的包名相同\n            if (name.startsWith(packageDirName)) {\n                int idx = name.lastIndexOf('/');\n                // 如果以\"/\"结尾 是一个包\n                if (idx != -1) {\n                    // 获取包名 把\"/\"替换成\".\"\n                    packageName = name.substring(0, idx).replace('/', '.');\n                }\n                // 如果可以迭代下去 并且是一个包\n                if ((idx != -1) || recursive) {\n                    // 如果是一个.class文件 而且不是目录\n                    if (name.endsWith(\".class\") && !entry.isDirectory()) {\n                        // 去掉后面的\".class\" 获取真正的类名\n                        String className = name.substring(packageName.length() + 1, name.length() - 6);\n                        try {\n                            // 添加到classes\n                            classes.add(Class.forName(packageName + '.' + className));\n                        } catch (ClassNotFoundException e) {\n                            // .error(\"添加用户自定义视图类错误 找不到此类的.class文件\");\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n","tags":["Spring"],"categories":["技术"]},{"title":"Java","url":"/2023/03/26/Java/Java/","content":"\n## **Java 特点**\n\njava语言特性\n\n- 面对对象：将重点放在数据和对象的接口上\n- 简单性：相比c++，减少了头文件、指针等很多概念，而且java可以在很小的机器上独立运行\n- Java语言是健壮的 : 强类型机制, 异常处理, 垃圾的自动收集\n- 跨平台性：java文件被编译成字节码文件，然后在不同的机器上可以通过JVM编译成机器码执行\n- 解释性语言：需要解释器来执行\n- 分布式：有丰富的例程库用于处理TCP/IP协议，可以通过URL访问网络上的对象\n\n<!--more-->\n\n## 环境搭建\n\n## IDEA 开发工具\n\n- 新建项目\n- 运行调试\n- 界面配置\n- 插件管理\n\n## Java 基础语法\n\n### 基础数据类型\n\n- 1字节8个bit\n\n- byte 1字节\n\n- short 2字节\n\n  byte short 运算时会转换到int类型\n\n- int 4字节\n\n- long 8字节\n\n- float 4字节\n\n- double 8字节\n  浮点数 = 符号位+指数位+尾数位\n  尾数位可能丢失造成精度丢失\n\n  浮点数的比较应该是两个数的差值的绝对值，在某个精度范围内判断（Math.abs(num1 - num2)<）\n\n- boolean 1字节\n\n- char 2字节\n\n### 流程控制\n\n- for\n- if\n- else if\n- while\n- dowhile\n- swich\n\n### 关键字\n\nfinal: final修饰的类不能被继承，修饰的方法不能重写，修饰的变量是基本数据类型不能改变，修饰的变量是引用类型不能指向其他的对象\n\n## 数组\n\n## *面向对象*\n\n使用原有的技术方法（单独定义和使用数组解决存储）不利于数据的管理，效率低下，代码的可重用性和可维护性差，重复性高，程序的可读性、可扩展性差。\n\n面对对象是一种编程思想。相比于传统的方法，解决了上面的问题，提供了类、对象、封装继承和多态的概念，面对对象更加的灵活，可以更好的满足复杂的业务需求。\n\n类是自定义的数据类型，是一种抽象的概念，描述了一类对象的共同特征\n\n对象是具体的实例，是类的具体表现\n\n### 面对对象的三大特征\n\n- 封装：把数据和操作数据的方法装在一起，外部不能直接调用访问内部数据\n\n- 继承：一个类从另一个类中继承属性和方法，减少代码重复\n\n- 多态：一个类可以拥有多种形态，根据不同的情况执行不同的操作\n\n  多态和继承的区别在于：继承是一种静态的关系，在编译时就可以确定，多态是动态的关系，在运行时才知道需要执行怎样的操作\n\n### 方法\n\n是类的行为\n\n#### 静态方法\n\n对象可以调用类的实例方法，但是不推荐这样做，这种方式会造成混淆，静态方法计算的结果跟对象没有关系。\n\n```java\nclass employee{\n\tpublic static getNextId(){}\n}\npublic void static main(String[] args){\n    Employee harry = new Employee();\n    harry.getNextId();\n    Employee.getNextId();\n}\n```\n\n#### 工厂方法\n\n#### 方法参数\n\n在java中方法参数传递的方式是值传递\n\n在方法中对传入的值进行处理的时候不会影响到原值\n\n但在对象的处理中，拷贝的对象引用的仍然是原有的地址，所以对对象中的属性操作时不会出现问题\n\n### 重载\n\n一个类中多个同名但是参数列表不同的方法\n\n### 重写\n\n子类重新定义父类中的方法，实现不同的功能\n\n### **对象的内存布局**\n\n![image-20230212191224066](\\Java.assets\\image-20230212191224066.png)\n\n## 继承\n\n#### super\n\nsuper与this不同，super不是对象的引用，不能将super赋给另外一个对象变量，只是一个指示编译器去调用父类方法的特殊关键字。\n\n#### 子类构造器\n\n用 super 实现对父类构造器的调用，使用 super 调用构造器的语句必须是子类构造器的第一条\n\n如果子类的构造器没有显式的调用父类的构造器，自动调用父类没有参数的构造器，如果父类没有无参构造器，则会编译错误 \n\n一个对象被指示为多种类型的情况被称为*多态*，运行时自动选择调用方法的现象叫做*动态绑定*\n\n#### 多态\n\n父类对象的任何地方都可以用子类对象置换，对象变量是多态的\n\n**注意：**\n\n```java\nManager[] managers = new Manager[3];\nmanagers[0] = boss;\n// 父类对象引用子类对象\nEmployee[] employees = managers; \n// 虽然是父类，但是数组的类型是子类，父类替换其中的元素会报错\nemployees[0] = employee; // java.lang.ArrayStoreException: object.Employee\nSystem.out.println(managers[0].getName()); \n```\n\n#### 强制类型转换\n\n- 只能在继承层次内进行类型转换\n- 将父类转换为子类之前，应该使用instanceof检查\n\n#### 抽象类\n\n是指只定义属性和行为的抽象概念，但是不实现\n\n包含一个或多个抽象方法的类必须声明为抽象的，抽象类中也可以含有具体的方法\n\n抽象类不能被实现，但是可以引用子类的对象\n\n```java\nPerson p = new Employee();\n```\n\n#### 访问修饰符\n\n| private   | 仅对本类可见         |\n| --------- | -------------------- |\n| public    | 所有都可见           |\n| protected | 对本包和所有子类可见 |\n| （不填）  | 对本包可见           |\n\n### Object\n\n#### equals\n\nequals的最好的流程\n\n```java\n@Override\npublic boolean equals(Object otherObject) {\n    // 检测 this 与 otherObject 是否引用同一个对象\n    if(this == otherObject) return true;\n    // 检测 otherObject 是否为 null\n    if(otherObject == null) return false;\n    // 比较 this 与 otherObject 是否属于同一个类。\n    // 如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测\n    // 如果所有的子类都拥有统一的语义，就使用 instanceof 检测\n    if(getClass() != otherObject.getClass()) return false;\n    // 将 otherObject 转换为相应的类类型变量\n    Employee other = (Employee) otherObject;\n    // 现在开始对所有需要比较的域进行比较。\n    return Objects.equals(name, other.name)\n            && salary == other.salary\n            && id == other.id;\n}\n```\n\n#### hashcode\n\n重新定义equals方法，就必须重新定义hashcode方法，在插入hash表时会计算插入对象的hash值决定插入的位置。\n\n```java\n@Override\npublic int hashCode() {\n    return Objects.hash(name, salary);\n}\n```\n\n### 继承的设计技巧\n\n1. 将公共操作和域放在父类\n2. 不要使用受保护的域\n3. 使用继承实现is-a关系\n4. 除非所有继承的方法都有意义，否则不要使用继承\n5. 覆盖方法时不要改变预期的行为\n6. 使用多态，而不是用类型信息\n7. 不要过多的使用反射\n\n## 接口\n\n指一组定义的方法，可以被其他类实现\n\n**抽象类和接口的区别**：抽象类可以包含抽象方法和非抽象方法，接口只能包含抽象方法，抽象类可以定义实例变量，接口不能\n\n每个类只可以扩展于一个类，但是可以实现多个接口\n\n### 接口的多态\n\n多态参数：作为参数传入方法，方法参数中可以使用实现了接口的类的对象实例\n\n多态数组：接口数组中可以存放不同的实现了接口的类的对象实例\n\n多态传递：接口B继承了其他的接口A时，实现了接口B的类也要实现接口A的方法\n\n## 类\n\n外部类\n\n内部类\n\n- 定义在外部类的局部位置上（方法内）\n\n  1. 局部内部类\n\n     ```java\n     class Outer { // 外部类\n     \n         private int n1 = 100;\n     \n         private void m2() {\n             System.out.println(\"m2 调用\");\n         }\n     \n         public void m1 () {\n             // 局部内部类写在方法或者代码块中\n             // 本质是一个局部变量 不能有访问修饰符 可以用final修饰\n             // 作用域只在定义的方法或者代码块中\n             final class Inner {\n                 private int n1 = 2000;\n     \n                 public void f1 () {\n                     // 可以调用外部类的私有变量和私有方法\n                     // 如果存在重名，采取就近原则，调用外部类时采用类名.this.变量名调用\n                     System.out.println(\"n1 = \" + n1 + \"Outer.this.n1 = \" + Outer.this.n1);\n                     m2();\n                 }\n             }\n             // 外部类 访问局部内部类的成员 只能在作用域内访问\n             Inner inner = new Inner();\n             int n11 = inner.n1;\n             inner.f1();\n         }\n     }\n     ```\n\n  2. 匿名内部类\n\n     ```java\n     \t// 匿名内部类\n         // 编译类型是IA\n         // 运行类型是 外部类类名$数字 LocalInnerClass$1\n         // 只进行一次用于实例化对象 在实现类使用次数少的情况下 简化实现类的编写\n         IA tiger = new IA (){\n             @Override\n             public void cry() {\n                 System.out.println(\"tiger crying...\");\n             }\n         };\n     interface IA{\n         void cry();\n     }\n     ```\n\n- 定义在成员位置\n\n  1. 成员内部类\n  2. 静态内部类\n\n其他类\n\n## 枚举\n\n```java\npublic enum Size {\n    SMALL(\"S\"), MEDIUM(\"M\"), LARGE(\"L\"), EXTRA_LARGE(\"XL\");\n\n    Size(String abbreviation) {\n        this.abbreviation = abbreviation;\n    }\n\n    private String abbreviation;\n\n    public String getAbbreviation() {\n        return abbreviation;\n    }\n}\n```\n\n比较两个枚举类型的值的时候直接用 == 就可以了\n\n## 常用类\n\n### String\n\nString 不可变，可以更改变量的原因是重新指向了新的对象，线程不安全\n\nStringBuffer 继承 AbstractStringBuilder，可变字符串，对方法加了同步锁线程安全\n\nStringBuilder 可变字符串，线程不安全，性能比StringBuffer提升10%-15%\n\n> Java9之后String AbstractStringBuilder 的实现改用byte数组存储字符串\n\n#### String 不可变\n\n用final关键字修饰字符数组，保存字符串的数组是私有的，String没有暴露修改这个字符数组的方法 （final修饰字符数组只是无法修改引用其他的对象，对于数组内部地址中存储的字符仍然可以修改）\n\n\n\n### 日期时间\n\nData\n\nCalendar\n\nTimeStamp\n\n## **集合类**\n\n集合主要分了两组：单列集合、双列集合\n\n### Collection\n\n- List\n\n  ArrayList 线程安全 初始化10个 每次扩容1.5倍\n\n  Vector 线程安全 初始化 每次扩容2倍\n\n  LinkedArrayList 底层是双向链表实现，插入删除方便\n\n- Set\n\n  HashSet 底层实现HashMap 无序\n\n  TreeSet 底层实现TreeMap\n\n### Map\n\n- HashMap 1.7之前底层数据结构是数组加链表，1.8之后是数组加链表加红黑树，当单条链表元素超过8并且数组长度大于64之后会将链表转为红黑树。每次扩容两倍，添加时先通过扰动函数`hash()`计算 hash 值，然后计算 `(len-1) ^ hash` 得到 插入的位置。\n- Hashtable \n- TreeMap 1.7\n- Properties 配置文件键值对\n- LinkedHashMap 输出有序 可以传入一个比较器，用来决定添加进元素的顺序并决定元素是否添加\n\n## 泛型\n\n## 注解\n\n## 异常处理\n\n## **多线程**\n\n### 进程线程\n\n进程是一个容器，有多个线程\n\n实现多线程可以通过\n\n- 继承Thread， 实现类调用start()方法\n- 实现Runable(Thread也是实现Runable)\n- 实现Callable\n\n区别：Thread 是继承，Runable是接口，实现了Runable也要通过new Thread静态代理。一个实现了Runable接口的类实例可以传入不同的Thread启动，Callable有返回值。\n\n### 线程七大状态\n\n新建--> （就绪 --> 运行）Runnable --> 死亡\n\n阻塞\n\n定时等待\n\n等待\n\n### 互斥锁\n\n### 死锁\n\n两个线程互相持有对方接下来需要的资源无法放弃自身拥有的资源而造成的阻塞情况。\n\n## IO 流\n\n### 流的分类\n\n- 按操作数据单位：字节流（8bit）二进制文件（音频，视频等，不会出现文件的损失），字符流（字符）文本文件\n- 流向：输入流，输出流\n- 角色：节点流、处理流/包装流\n\n|            | **字节流**   | **字符流** |\n| ---------- | ------------ | ---------- |\n| **输入流** | InputStream  | Reader     |\n| **输出流** | OutputStream | Writer     |\n\n### InputStream\n\nFileInputStream\n\nBufferedInputStream\n\nObjectInputStream \n\n### OutputStream\n\nFileOutputStream\n\n## 反射\n\n反射可以用来在运行时动态操作Java代码，分析类能力\n\n反射的作用：\n\n- 运行时分析类的能力\n- 运行时查看对象\n- 实现通用的数组操作代码\n- 利用method对象，运行时调用方法\n\n### 运行时利用反射分析对象\n\n获取对象域\n\n```java\nEmployee harry = new Employee(\"Harry Hacker\", 21, 35000);\nClass<? extends Employee> cl = harry.getClass();\nField name = cl.getDeclaredField(\"name\");\n// name是私有\nname.setAccessible(true);\nObject o = name.get(harry);\n```\n\n### 数组复制\n\n```java\n public static Object goodCopyOf(Object a, int newLength) {\n     Class cl = a.getClass();\n     if (!cl.isArray()) return null;\n     Class componentType = cl.getComponentType();\n     int length = Array.getLength(a);\n     Object o = Array.newInstance(componentType, length);\n     System.arraycopy(a, 0, o, 0, Math.min(length, newLength));\n     return o;\n}\n```\n\n### 使用Method\n\n```java\nMethod m1 = Employee.class.getMethod(\"getName\");\n```\n\n### 反射实例\n\n#### 框架\n\n文档 ：Spring IOC \n\n#### 动态代理\n\n#### 序列化和反序列化\n\n\n\n","tags":["Java基础"],"categories":["技术"]}]