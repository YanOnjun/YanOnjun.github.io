<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring编程思想</title>
    <url>/2023/03/26/Java/Spring/</url>
    <content><![CDATA[<h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>IOC （inversion of control）控制反转，是一种编程思想，对面对对象的补充，通过将对象的创建，组装，管理反转在框架中进行，实现低耦合和可重用性</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>创建工厂</p>
<p>读取配置文件</p>
<p>通过配置文件创建实例</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>三层架构 Dao - Service - Controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HelloDao</span> <span class="variable">helloDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloDaoImpl</span>();</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helloDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;spring&quot;</span>  + helloService.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>当需求发生改变时，代码需要更改，要重写接口代码</p>
<p><strong>解决：</strong> 使用静态工厂创建特定的类，不用在Service中写死代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HelloDao <span class="title function_">getDao</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">HelloDao</span> <span class="variable">helloDao</span> <span class="operator">=</span> BeanFactory.getDao();</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong>需求发生改变时 仍然需要修改代码</p>
<p>解决：使用反射从配置文件中获取具体的类</p>
<ol>
<li><p>定义配置文件</p>
</li>
<li><p>程序中读取配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用工厂创建特定的类，不用写死在Service中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * version1  public static HelloDao getDao()&#123;</span></span><br><span class="line"><span class="comment">     *         return new HelloDaoImpl();</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">helloDao</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;helloDao&quot;</span>);</span><br><span class="line">        <span class="comment">// 利用反射创建对象</span></span><br><span class="line">        <span class="comment">// 通过更改配置文件就可以解决代码不能切换的问题</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(helloDao);</span><br><span class="line">            <span class="keyword">return</span> aClass.getConstructor( <span class="literal">null</span>).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | InvocationTargetException | InstantiationException | IllegalAccessException |</span><br><span class="line">                 NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;application.properties&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<p>之后使用外部配置修改解决代码切换的问题</p>
</li>
</ol>
</li>
</ol>
<p><strong>创建的对象不是单例</strong></p>
<p>重复使用对象会出现使用很多个实例的问题</p>
<p>解决：使用 Map 存放创建的对象，同时加锁保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getDao</span><span class="params">(String beanName)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(beanName))&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BeanFactory.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!cache.containsKey(beanName))&#123;</span><br><span class="line">                    <span class="comment">// 利用反射创建对象</span></span><br><span class="line">                    <span class="comment">// 通过更改配置文件就可以解决代码不能切换的问题</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">helloDao</span> <span class="operator">=</span> properties.getProperty(beanName);</span><br><span class="line">                        Class&lt;?&gt; aClass = Class.forName(helloDao);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.getConstructor(<span class="literal">null</span>).newInstance();</span><br><span class="line">                        cache.put(beanName, o);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException | InvocationTargetException | InstantiationException | IllegalAccessException |</span><br><span class="line">                             NoSuchMethodException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.get(beanName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>放弃创造对象的权限，将权限交给 BeanFactory</p>
<p>这种由别人或者对象控制的思想就是 <strong>IOC 控制反转</strong></p>
<h1 id="基于注解的-IOC"><a href="#基于注解的-IOC" class="headerlink" title="基于注解的 IOC"></a>基于注解的 IOC</h1><p>通过配置文件获取还是很麻烦，根据注解创建 Bean 实例，通过注解获取到 Bean 实例更为方便</p>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><p><img src="https://article-images.zsxq.com/Fr5lKUGA910wfJcrKhb7wMitvUKy" alt="img"></p>
<ol>
<li><p>扫描包</p>
</li>
<li><p>获取包下添加了注解的类，获取其中的组件 Class 和 BeanName 封装成 BeanDefination 存入集合，这个集合就是 IOC 自动装载的原材料</p>
</li>
<li><p>通过反射机制创建对象，将动态创建的对象以 Map 的形式存入缓存</p>
</li>
<li><p>通过 BeanName 取出对应的 Bean, 使用反射执行方法</p>
</li>
</ol>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Object&gt; ioc =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ioc.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAnnotationConfigApplicationContext</span><span class="params">(String pack)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 扫描包</span></span><br><span class="line">        <span class="comment">//2. 获取包下添加了注解的类，获取其中的组件 Class 和 BeanName 封装成 BeanDefination 存入集合，这个集合就是 IOC 自动装载的原材料</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; beanDefinition = findBeanDefinition(pack);</span><br><span class="line">        <span class="comment">//3. 通过反射机制创建对象，将动态创建的对象以 Map 的形式存入缓存</span></span><br><span class="line">        createObject(beanDefinition);</span><br><span class="line">        <span class="comment">// 自动装载</span></span><br><span class="line">		autowireObject(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowireObject</span><span class="params">(Set&lt;BeanDefinition&gt; beanDefinitions)</span> &#123;</span><br><span class="line">        <span class="comment">//获取注入的集合</span></span><br><span class="line">        Iterator&lt;BeanDefinition&gt; iterator = beanDefinitions.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//拿到bean 信息</span></span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="comment">//获取当前需要自动装配的对象</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> beanDefinition.getBeanClass();</span><br><span class="line">            <span class="comment">//拿到全部属性</span></span><br><span class="line">            Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">                <span class="type">Autowired</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Autowired.class);</span><br><span class="line">                <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Qualifer</span> <span class="variable">qualifer</span> <span class="operator">=</span> field.getAnnotation(Qualifer.class);</span><br><span class="line">                    <span class="keyword">if</span> (qualifer != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 根据字段的名字获取</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> qualifer.value();</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(beanName);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> field.getName();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">mothedName</span> <span class="operator">=</span> <span class="string">&quot;set&quot;</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line">                            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(mothedName, field.getType());</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> getBean(beanDefinition.getBeanName());</span><br><span class="line">                            System.out.println(bean);</span><br><span class="line">                            method.invoke(object, bean);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//byType</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObject</span><span class="params">(Set&lt;BeanDefinition&gt; beanDefinitions)</span> &#123;</span><br><span class="line">        Iterator&lt;BeanDefinition&gt; iterator = beanDefinitions.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> beanDefinition.getBeanClass();</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> beanDefinition.getBeanName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> beanClass.getConstructor().newInstance();</span><br><span class="line">                <span class="comment">// 属性字段 设置值</span></span><br><span class="line">                Field[] declaredFields = beanClass.getDeclaredFields();</span><br><span class="line">                <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">                    <span class="type">Value</span> <span class="variable">valueAnnotation</span> <span class="operator">=</span> declaredField.getAnnotation(Value.class);</span><br><span class="line">                    <span class="keyword">if</span> (valueAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> valueAnnotation.value();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> declaredField.getName();</span><br><span class="line">                        <span class="comment">// set方法</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;set&quot;</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line">                        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> beanClass.getMethod(methodName, declaredField.getType());</span><br><span class="line">                        <span class="comment">//数据类型转换</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//可能会有很多类型 篇幅过长</span></span><br><span class="line">                        <span class="keyword">switch</span> (declaredField.getType().getName()) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;java.lang.Integer&quot;</span>:</span><br><span class="line">                                val = Integer.parseInt(value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;java.lang.String&quot;</span>:</span><br><span class="line">                                val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;java.lang.Float&quot;</span>:</span><br><span class="line">                                val = Float.parseFloat(value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 执行</span></span><br><span class="line">                        method.invoke(o, val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ioc.put(beanName, o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException |</span><br><span class="line">                     NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包中符合条件的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findBeanDefinition</span><span class="params">(String pack)</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取包下所有类</span></span><br><span class="line">        HashSet&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Class&gt; classes = getClasses(pack);</span><br><span class="line">        Iterator&lt;Class&gt; iterator = classes.iterator();</span><br><span class="line">        <span class="comment">// 2. 遍历类，找到添加了注解的类</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="type">Component</span> <span class="variable">annotation</span> <span class="operator">=</span> (Component) clazz.getAnnotation(Component.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取Component的值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">                    <span class="comment">// 获取类名</span></span><br><span class="line">                    beanName = clazz.getSimpleName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(clazz, beanName);</span><br><span class="line">                beanDefinitions.add(beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 将这些类封装成BeanDefinition装载到集合中</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get classes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&gt; <span class="title function_">getClasses</span><span class="params">(String pack)</span>&#123;</span><br><span class="line">        Set&lt;Class&gt; classes = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// get package name and replace to url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> pack;</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageDirName</span> <span class="operator">=</span> packageName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);</span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// get next element</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> dirs.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> url.getProtocol();</span><br><span class="line">                <span class="comment">// if it is saved at server like a file</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">decode</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    findClassesInPackageByFile(packageName, decode, <span class="literal">true</span>, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;jar类型的扫描&quot;</span>);</span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection()).getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        findClassesInPackageByJar(packageName, entries, packageDirName, <span class="literal">true</span>, classes);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findClassesInPackageByFile</span><span class="params">(String packageName, String packagePath, <span class="keyword">final</span> <span class="type">boolean</span> recursive, Set&lt;Class&gt; classes)</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(packagePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!dir.exists() || !dir.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取目录下的目录和以.class结尾的文件</span></span><br><span class="line">        File[] dirFiles = dir.listFiles(file -&gt; (recursive &amp;&amp; file.isDirectory()) || file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (File dirFile : dirFiles) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dirFile.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">// 目录继续往里找</span></span><br><span class="line">                findClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span> + dirFile.getName(), dirFile.getAbsolutePath(), recursive, classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 去除.class</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">classFileName</span> <span class="operator">=</span> dirFile.getName().substring(<span class="number">0</span>, dirFile.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="comment">// 添加进class</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&quot;.&quot;</span> + classFileName));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findClassesInPackageByJar</span><span class="params">(String packageName, Enumeration&lt;JarEntry&gt; entries, String packageDirName, <span class="keyword">final</span> <span class="type">boolean</span> recursive, Set&lt;Class&gt; classes)</span> &#123;</span><br><span class="line">        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">            <span class="type">JarEntry</span> <span class="variable">entry</span> <span class="operator">=</span> entries.nextElement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getName();</span><br><span class="line">            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                name = name.substring(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                    packageName = name.substring(<span class="number">0</span>, idx).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> name.substring(packageName.length() + <span class="number">1</span>, name.length() - <span class="number">6</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 添加到classes</span></span><br><span class="line">                            classes.add(Class.forName(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2023/03/26/Java/Java/</url>
    <content><![CDATA[<h2 id="Java-特点"><a href="#Java-特点" class="headerlink" title="Java 特点"></a><strong>Java 特点</strong></h2><p>java语言特性</p>
<ul>
<li>面对对象：将重点放在数据和对象的接口上</li>
<li>简单性：相比c++，减少了头文件、指针等很多概念，而且java可以在很小的机器上独立运行</li>
<li>Java语言是健壮的 : 强类型机制, 异常处理, 垃圾的自动收集</li>
<li>跨平台性：java文件被编译成字节码文件，然后在不同的机器上可以通过JVM编译成机器码执行</li>
<li>解释性语言：需要解释器来执行</li>
<li>分布式：有丰富的例程库用于处理TCP&#x2F;IP协议，可以通过URL访问网络上的对象</li>
</ul>
<span id="more"></span>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h2 id="IDEA-开发工具"><a href="#IDEA-开发工具" class="headerlink" title="IDEA 开发工具"></a>IDEA 开发工具</h2><ul>
<li>新建项目</li>
<li>运行调试</li>
<li>界面配置</li>
<li>插件管理</li>
</ul>
<h2 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul>
<li><p>1字节8个bit</p>
</li>
<li><p>byte 1字节</p>
</li>
<li><p>short 2字节</p>
<p>byte short 运算时会转换到int类型</p>
</li>
<li><p>int 4字节</p>
</li>
<li><p>long 8字节</p>
</li>
<li><p>float 4字节</p>
</li>
<li><p>double 8字节<br>浮点数 &#x3D; 符号位+指数位+尾数位<br>尾数位可能丢失造成精度丢失</p>
<p>浮点数的比较应该是两个数的差值的绝对值，在某个精度范围内判断（Math.abs(num1 - num2)&lt;）</p>
</li>
<li><p>boolean 1字节</p>
</li>
<li><p>char 2字节</p>
</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li>for</li>
<li>if</li>
<li>else if</li>
<li>while</li>
<li>dowhile</li>
<li>swich</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>final: final修饰的类不能被继承，修饰的方法不能重写，修饰的变量是基本数据类型不能改变，修饰的变量是引用类型不能指向其他的对象</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><em>面向对象</em></h2><p>使用原有的技术方法（单独定义和使用数组解决存储）不利于数据的管理，效率低下，代码的可重用性和可维护性差，重复性高，程序的可读性、可扩展性差。</p>
<p>面对对象是一种编程思想。相比于传统的方法，解决了上面的问题，提供了类、对象、封装继承和多态的概念，面对对象更加的灵活，可以更好的满足复杂的业务需求。</p>
<p>类是自定义的数据类型，是一种抽象的概念，描述了一类对象的共同特征</p>
<p>对象是具体的实例，是类的具体表现</p>
<h3 id="面对对象的三大特征"><a href="#面对对象的三大特征" class="headerlink" title="面对对象的三大特征"></a>面对对象的三大特征</h3><ul>
<li><p>封装：把数据和操作数据的方法装在一起，外部不能直接调用访问内部数据</p>
</li>
<li><p>继承：一个类从另一个类中继承属性和方法，减少代码重复</p>
</li>
<li><p>多态：一个类可以拥有多种形态，根据不同的情况执行不同的操作</p>
<p>多态和继承的区别在于：继承是一种静态的关系，在编译时就可以确定，多态是动态的关系，在运行时才知道需要执行怎样的操作</p>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>是类的行为</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>对象可以调用类的实例方法，但是不推荐这样做，这种方式会造成混淆，静态方法计算的结果跟对象没有关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getNextId</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    harry.getNextId();</span><br><span class="line">    Employee.getNextId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>在java中方法参数传递的方式是值传递</p>
<p>在方法中对传入的值进行处理的时候不会影响到原值</p>
<p>但在对象的处理中，拷贝的对象引用的仍然是原有的地址，所以对对象中的属性操作时不会出现问题</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>一个类中多个同名但是参数列表不同的方法</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类重新定义父类中的方法，实现不同的功能</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><strong>对象的内存布局</strong></h3><p><img src="/%5CJava.assets%5Cimage-20230212191224066.png" alt="image-20230212191224066"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>super与this不同，super不是对象的引用，不能将super赋给另外一个对象变量，只是一个指示编译器去调用父类方法的特殊关键字。</p>
<h4 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h4><p>用 super 实现对父类构造器的调用，使用 super 调用构造器的语句必须是子类构造器的第一条</p>
<p>如果子类的构造器没有显式的调用父类的构造器，自动调用父类没有参数的构造器，如果父类没有无参构造器，则会编译错误 </p>
<p>一个对象被指示为多种类型的情况被称为<em>多态</em>，运行时自动选择调用方法的现象叫做<em>动态绑定</em></p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>父类对象的任何地方都可以用子类对象置换，对象变量是多态的</p>
<p><strong>注意：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> <span class="title class_">Manager</span>[<span class="number">3</span>];</span><br><span class="line">managers[<span class="number">0</span>] = boss;</span><br><span class="line"><span class="comment">// 父类对象引用子类对象</span></span><br><span class="line">Employee[] employees = managers; </span><br><span class="line"><span class="comment">// 虽然是父类，但是数组的类型是子类，父类替换其中的元素会报错</span></span><br><span class="line">employees[<span class="number">0</span>] = employee; <span class="comment">// java.lang.ArrayStoreException: object.Employee</span></span><br><span class="line">System.out.println(managers[<span class="number">0</span>].getName()); </span><br></pre></td></tr></table></figure>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li>只能在继承层次内进行类型转换</li>
<li>将父类转换为子类之前，应该使用instanceof检查</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>是指只定义属性和行为的抽象概念，但是不实现</p>
<p>包含一个或多个抽象方法的类必须声明为抽象的，抽象类中也可以含有具体的方法</p>
<p>抽象类不能被实现，但是可以引用子类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br></pre></td></tr></table></figure>

<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><table>
<thead>
<tr>
<th>private</th>
<th>仅对本类可见</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>所有都可见</td>
</tr>
<tr>
<td>protected</td>
<td>对本包和所有子类可见</td>
</tr>
<tr>
<td>（不填）</td>
<td>对本包可见</td>
</tr>
</tbody></table>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>equals的最好的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">    <span class="comment">// 检测 this 与 otherObject 是否引用同一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 检测 otherObject 是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 比较 this 与 otherObject 是否属于同一个类。</span></span><br><span class="line">    <span class="comment">// 如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测</span></span><br><span class="line">    <span class="comment">// 如果所有的子类都拥有统一的语义，就使用 instanceof 检测</span></span><br><span class="line">    <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将 otherObject 转换为相应的类类型变量</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br><span class="line">    <span class="comment">// 现在开始对所有需要比较的域进行比较。</span></span><br><span class="line">    <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">            &amp;&amp; salary == other.salary</span><br><span class="line">            &amp;&amp; id == other.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p>重新定义equals方法，就必须重新定义hashcode方法，在插入hash表时会计算插入对象的hash值决定插入的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol>
<li>将公共操作和域放在父类</li>
<li>不要使用受保护的域</li>
<li>使用继承实现is-a关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>覆盖方法时不要改变预期的行为</li>
<li>使用多态，而不是用类型信息</li>
<li>不要过多的使用反射</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>指一组定义的方法，可以被其他类实现</p>
<p><strong>抽象类和接口的区别</strong>：抽象类可以包含抽象方法和非抽象方法，接口只能包含抽象方法，抽象类可以定义实例变量，接口不能</p>
<p>每个类只可以扩展于一个类，但是可以实现多个接口</p>
<h3 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h3><p>多态参数：作为参数传入方法，方法参数中可以使用实现了接口的类的对象实例</p>
<p>多态数组：接口数组中可以存放不同的实现了接口的类的对象实例</p>
<p>多态传递：接口B继承了其他的接口A时，实现了接口B的类也要实现接口A的方法</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>外部类</p>
<p>内部类</p>
<ul>
<li><p>定义在外部类的局部位置上（方法内）</p>
<ol>
<li><p>局部内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">// 外部类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部内部类写在方法或者代码块中</span></span><br><span class="line">        <span class="comment">// 本质是一个局部变量 不能有访问修饰符 可以用final修饰</span></span><br><span class="line">        <span class="comment">// 作用域只在定义的方法或者代码块中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span> <span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 可以调用外部类的私有变量和私有方法</span></span><br><span class="line">                <span class="comment">// 如果存在重名，采取就近原则，调用外部类时采用类名.this.变量名调用</span></span><br><span class="line">                System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot;Outer.this.n1 = &quot;</span> + Outer.<span class="built_in">this</span>.n1);</span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 外部类 访问局部内部类的成员 只能在作用域内访问</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n11</span> <span class="operator">=</span> inner.n1;</span><br><span class="line">        inner.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 匿名内部类</span></span><br><span class="line">    <span class="comment">// 编译类型是IA</span></span><br><span class="line">    <span class="comment">// 运行类型是 外部类类名$数字 LocalInnerClass$1</span></span><br><span class="line">    <span class="comment">// 只进行一次用于实例化对象 在实现类使用次数少的情况下 简化实现类的编写</span></span><br><span class="line">    <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span> ()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;tiger crying...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>定义在成员位置</p>
<ol>
<li>成员内部类</li>
<li>静态内部类</li>
</ol>
</li>
</ul>
<p>其他类</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Size(String abbreviation) &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较两个枚举类型的值的时候直接用 &#x3D;&#x3D; 就可以了</p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 不可变，可以更改变量的原因是重新指向了新的对象，线程不安全</p>
<p>StringBuffer 继承 AbstractStringBuilder，可变字符串，对方法加了同步锁线程安全</p>
<p>StringBuilder 可变字符串，线程不安全，性能比StringBuffer提升10%-15%</p>
<blockquote>
<p>Java9之后String AbstractStringBuilder 的实现改用byte数组存储字符串</p>
</blockquote>
<h4 id="String-不可变"><a href="#String-不可变" class="headerlink" title="String 不可变"></a>String 不可变</h4><p>用final关键字修饰字符数组，保存字符串的数组是私有的，String没有暴露修改这个字符数组的方法 （final修饰字符数组只是无法修改引用其他的对象，对于数组内部地址中存储的字符仍然可以修改）</p>
<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p>Data</p>
<p>Calendar</p>
<p>TimeStamp</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a><strong>集合类</strong></h2><p>集合主要分了两组：单列集合、双列集合</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul>
<li><p>List</p>
<p>ArrayList 线程安全 初始化10个 每次扩容1.5倍</p>
<p>Vector 线程安全 初始化 每次扩容2倍</p>
<p>LinkedArrayList 底层是双向链表实现，插入删除方便</p>
</li>
<li><p>Set</p>
<p>HashSet 底层实现HashMap 无序</p>
<p>TreeSet 底层实现TreeMap</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>HashMap 1.7之前底层数据结构是数组加链表，1.8之后是数组加链表加红黑树，当单条链表元素超过8并且数组长度大于64之后会将链表转为红黑树。每次扩容两倍，添加时先通过扰动函数<code>hash()</code>计算 hash 值，然后计算 <code>(len-1) ^ hash</code> 得到 插入的位置。</li>
<li>Hashtable </li>
<li>TreeMap 1.7</li>
<li>Properties 配置文件键值对</li>
<li>LinkedHashMap 输出有序 可以传入一个比较器，用来决定添加进元素的顺序并决定元素是否添加</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h2><h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><p>进程是一个容器，有多个线程</p>
<p>实现多线程可以通过</p>
<ul>
<li>继承Thread， 实现类调用start()方法</li>
<li>实现Runable(Thread也是实现Runable)</li>
<li>实现Callable</li>
</ul>
<p>区别：Thread 是继承，Runable是接口，实现了Runable也要通过new Thread静态代理。一个实现了Runable接口的类实例可以传入不同的Thread启动，Callable有返回值。</p>
<h3 id="线程七大状态"><a href="#线程七大状态" class="headerlink" title="线程七大状态"></a>线程七大状态</h3><p>新建–&gt; （就绪 –&gt; 运行）Runnable –&gt; 死亡</p>
<p>阻塞</p>
<p>定时等待</p>
<p>等待</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个线程互相持有对方接下来需要的资源无法放弃自身拥有的资源而造成的阻塞情况。</p>
<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul>
<li>按操作数据单位：字节流（8bit）二进制文件（音频，视频等，不会出现文件的损失），字符流（字符）文本文件</li>
<li>流向：输入流，输出流</li>
<li>角色：节点流、处理流&#x2F;包装流</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>字节流</strong></th>
<th><strong>字符流</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入流</strong></td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td><strong>输出流</strong></td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>FileInputStream</p>
<p>BufferedInputStream</p>
<p>ObjectInputStream </p>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>FileOutputStream</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射可以用来在运行时动态操作Java代码，分析类能力</p>
<p>反射的作用：</p>
<ul>
<li>运行时分析类的能力</li>
<li>运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用method对象，运行时调用方法</li>
</ul>
<h3 id="运行时利用反射分析对象"><a href="#运行时利用反射分析对象" class="headerlink" title="运行时利用反射分析对象"></a>运行时利用反射分析对象</h3><p>获取对象域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>, <span class="number">21</span>, <span class="number">35000</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; cl = harry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// name是私有</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> name.get(harry);</span><br></pre></td></tr></table></figure>

<h3 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopyOf</span><span class="params">(Object a, <span class="type">int</span> newLength)</span> &#123;</span><br><span class="line">     <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">     <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> cl.getComponentType();</span><br><span class="line">     <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">     <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Array.newInstance(componentType, length);</span><br><span class="line">     System.arraycopy(a, <span class="number">0</span>, o, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">     <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Method"><a href="#使用Method" class="headerlink" title="使用Method"></a>使用Method</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="反射实例"><a href="#反射实例" class="headerlink" title="反射实例"></a>反射实例</h3><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>文档 ：Spring IOC </p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang</title>
    <url>/2023/03/26/Golang/Golang/</url>
    <content><![CDATA[<h1 id="包、变量和函数"><a href="#包、变量和函数" class="headerlink" title="包、变量和函数"></a>包、变量和函数</h1><p>每个 Go 程序都是由包构成的。</p>
<p>程序从 <code>main</code> 包开始运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此代码用圆括号组合了导入，这是“分组”形式的导入语句。</p>
<p>当然你也可以编写多个导入语句，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过使用分组导入语句是更好的形式。</p>
<p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">math.Pi</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以没有参数或接受多个参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数可以返回任意数量的返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>
<p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回。</p>
<p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p>
<p><code>var</code> 语句可以出现在包或函数级别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量声明可以包含初始值，每个变量对应一个。</p>
<p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">	fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>
<p>零值是：</p>
<ul>
<li>数值类型为 <code>0</code>，</li>
<li>布尔类型为 <code>false</code>，</li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>
</ul>
<p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p>
<p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	k := <span class="number">3</span></span><br><span class="line">	c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Go 的基本类型有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">    // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure>

<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型</p>
<p> 同导入语句一样，变量声明也可以“分组”成一个语法块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">	MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">	z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>Go 在不同类型的项之间赋值时需要显式转换</p>
<p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>
<p>一些关于数值的转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure>

<p>或者，更加简单的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="type">float64</span>(i)</span><br><span class="line">u := <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>
<p>常量可以是字符、字符串、布尔值或数值。</p>
<p>常量不能用 <code>:=</code> 语法声明。</p>
<h1 id="流程控制语句：for、if、else、switch-和-defer"><a href="#流程控制语句：for、if、else、switch-和-defer" class="headerlink" title="流程控制语句：for、if、else、switch 和 defer"></a>流程控制语句：for、if、else、switch 和 defer</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go 只有一种循环结构：<code>for</code> 循环。</p>
<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p>
<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化语句和后置语句可以去掉 此时分号也可以去掉  类似while</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sum&lt;<span class="number">1000</span> &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略条件则形成无限循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>Go 的 <code>if</code> 语句表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 <code>if</code> 和 <code>else</code> 之内</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句</p>
<p> Go 只运行选定的 case，而非之后所有的 case。Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句,除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>没有条件的 switch 同 <code>switch true</code> 一样。</p>
<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br></pre></td></tr></table></figure>

<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更多类型：struct、slice-和映射"><a href="#更多类型：struct、slice-和映射" class="headerlink" title="更多类型：struct、slice 和映射"></a>更多类型：struct、slice 和映射</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p *int</span><br></pre></td></tr></table></figure>

<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 42</span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>

<p><code>*</code> 操作符表示指针指向的底层值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmt.Println(*p) // 通过指针 p 读取 i</span><br><span class="line">*p = 21         // 通过指针 p 设置 i</span><br></pre></td></tr></table></figure>

<p>这也就是通常所说的“间接引用”或“重定向”。</p>
<p>Go 没有指针运算。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">	p := &amp;i         <span class="comment">// 指向 i</span></span><br><span class="line">	fmt.Println(*p) <span class="comment">// 通过指针读取 i 的值</span></span><br><span class="line">	*p = <span class="number">21</span>         <span class="comment">// 通过指针设置 i 的值</span></span><br><span class="line">	fmt.Println(i)  <span class="comment">// 查看 i 的值</span></span><br><span class="line"></span><br><span class="line">	p = &amp;j         <span class="comment">// 指向 j</span></span><br><span class="line">	*p = *p / <span class="number">37</span>   <span class="comment">// 通过指针对 j 进行除法运算</span></span><br><span class="line">	fmt.Println(j) <span class="comment">// 查看 j 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>一个结构体（<code>struct</code>）就是一组字段（field）。</p>
<p>结构体字段使用点号来访问。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span></span><br><span class="line">	Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    v.X = <span class="number">4</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体字段可以通过结构体指针来访问。</p>
<p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	p := &amp;v</span><br><span class="line">	p.X = <span class="number">1e9</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体文法通过直接列出字段的值来新分配一个结构体。</p>
<p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p>
<p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">	v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">	v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">	p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure>

<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p>数组的长度是其类型的一部分，因此数组不能改变大小。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure>

<p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>
<p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[1:4]</span><br></pre></td></tr></table></figure>

<p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p>
<p>更改切片的元素会修改其底层数组中对应的元素。</p>
<p>与它共享底层数组的切片都会观测到这些修改。</p>
<p>切片文法类似于没有长度的数组文法。</p>
<p>这是一个数组文法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>

<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>



<p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>
<p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p>
<p>对于数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure>

<p>来说，以下切片是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[0:10]</span><br><span class="line">a[:10]</span><br><span class="line">a[0:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure>

<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>
<p>切片的长度就是它所包含的元素个数。</p>
<p>切片的容量是从切片的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>
<p>切片的零值是 <code>nil</code>。</p>
<p>nil 切片的长度和容量为 0 且没有底层数组。</p>
<p><strong>用 make 创建切片</strong></p>
<p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure>

<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br></pre></td></tr></table></figure>



<p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。内建函数的<a href="https://go-zh.org/pkg/builtin/#append">文档</a>对此函数有详细的介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func append(s []T, vs ...T) []T</span><br></pre></td></tr></table></figure>

<p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p>
<p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>
<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
<p><strong>文章 <a href="https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a>。</strong></p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i, _ := range pow</span><br><span class="line">for _, value := range pow</span><br></pre></td></tr></table></figure>

<p>若只需要索引，忽略第二个变量即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i := range pow</span><br></pre></td></tr></table></figure>

<h2 id="练习：切片"><a href="#练习：切片" class="headerlink" title="练习：切片"></a>练习：切片</h2><p>实现 <code>Pic</code>。它应当返回一个长度为 <code>dy</code> 的切片，其中每个元素是一个长度为 <code>dx</code>，元素类型为 <code>uint8</code> 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。</p>
<p>图像的选择由你来定。几个有趣的函数包括 <code>(x+y)/2</code>, <code>x*y</code>, <code>x^y</code>, <code>x*log(y)</code> 和 <code>x%(y+1)</code>。</p>
<p>（提示：需要使用循环来分配 <code>[][]uint8</code> 中的每个 <code>[]uint8</code>；请使用 <code>uint8(intValue)</code> 在类型之间转换；你可能会用到 <code>math</code> 包中的函数。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/pic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line">	dySlice := [][]<span class="type">uint8</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;dy; i++ &#123;</span><br><span class="line">		dxSlice := <span class="built_in">make</span>([]<span class="type">uint8</span>,dx)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;dx; j++ &#123;</span><br><span class="line">			dxSlice[j] = <span class="type">uint8</span>((i%(j+<span class="number">1</span>)))</span><br><span class="line">		&#125;</span><br><span class="line">		dySlice = <span class="built_in">append</span>(dySlice, dxSlice)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dySlice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pic.Show(Pic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射将键映射到值。</p>
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">	m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在映射 <code>m</code> 中插入或修改元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure>

<p>获取元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure>

<p>删除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(m, key)</span><br></pre></td></tr></table></figure>

<p>通过双赋值检测某个键是否存在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>

<p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p>
<p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>
<h2 id="练习：映射"><a href="#练习：映射" class="headerlink" title="练习：映射"></a>练习：映射</h2><p>实现 <code>WordCount</code>。它应当返回一个映射，其中包含字符串 <code>s</code> 中每个“单词”的个数。函数 <code>wc.Test</code> 会对此函数执行一系列测试用例，并输出成功还是失败。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WordCount</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">	strs := strings.Fields(s)</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> strs &#123;</span><br><span class="line">		elem := m[v] + <span class="number">1</span></span><br><span class="line">		m[v] = elem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wc.Test(WordCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="H:\Users\zx065\Desktop\Java\Untitled.assets\image-20230317085357965.png" alt="image-20230317085357965"></p>
<h2 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h2><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos, neg := adder(), adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(</span><br><span class="line">			pos(i),</span><br><span class="line">			neg(<span class="number">-2</span>*i),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习：斐波纳契闭包"><a href="#练习：斐波纳契闭包" class="headerlink" title="练习：斐波纳契闭包"></a>练习：斐波纳契闭包</h2><p>让我们用函数做些好玩的事情。</p>
<p>实现一个 <code>fibonacci</code> 函数，它返回一个函数（闭包），该闭包返回一个<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波纳契数列</a> <code>(0, 1, 1, 2, 3, 5, ...)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	first := <span class="number">0</span></span><br><span class="line">	second := <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		back := first</span><br><span class="line">		first, second = second, first + second</span><br><span class="line">		<span class="keyword">return</span> back</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。</p>
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
<p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
<p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以为非结构体类型声明方法。</p>
<p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p>
<p>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法。</p>
<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h2><p>你可以为指针接收者声明方法。</p>
<p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p>
<p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>
<p>移除 <code>Scale</code> 函数声明中的 <code>*</code>，输出结果为5。</p>
<p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h2><p>带指针参数的函数必须接受一个指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">ScaleFunc(v, 5)  // 编译错误！</span><br><span class="line">ScaleFunc(&amp;v, 5) // OK</span><br></pre></td></tr></table></figure>

<p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">v.Scale(5)  // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(10) // OK</span><br></pre></td></tr></table></figure>

<p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</p>
<p>同样的事情也发生在相反的方向。</p>
<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  // OK</span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br></pre></td></tr></table></figure>

<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(v.Abs()) // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) // OK</span><br></pre></td></tr></table></figure>

<p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p>
<p>使用指针接收者的原因有二：</p>
<p>首先，方法能够修改其接收者指向的值。</p>
<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>
<p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p>
<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p>
<p>接口类型的变量可以保存任何实现了这些方法的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"><span class="comment">// MyFloat实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *Vertex 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h2><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>
<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">	i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure>

<p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p>
<p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p>
<p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure>

<p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p>
<p>请注意这种语法和读取一个映射时的相同之处。</p>
<h2 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h2><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。类似java object中的toString()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure>

<p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p>
<h2 id="练习：错误"><a href="#练习：错误" class="headerlink" title="练习：错误"></a>练习：错误</h2><p>从<a href="https://tour.go-zh.org/flowcontrol/8">之前的练习</a>中复制 <code>Sqrt</code> 函数，修改它使其返回 <code>error</code> 值。</p>
<p><code>Sqrt</code> 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。</p>
<p>创建一个新的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ErrNegativeSqrt float64</span><br></pre></td></tr></table></figure>

<p>并为其实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (e ErrNegativeSqrt) Error() string</span><br></pre></td></tr></table></figure>

<p>方法使其拥有 <code>error</code> 值，通过 <code>ErrNegativeSqrt(-2).Error()</code> 调用该方法应返回 <code>&quot;cannot Sqrt negative number: -2&quot;</code>。</p>
<p><strong>注意:</strong> 在 <code>Error</code> 方法内调用 <code>fmt.Sprint(e)</code> 会让程序陷入死循环。可以通过先转换 <code>e</code> 来避免这个问题：<code>fmt.Sprint(float64(e))</code>。这是为什么呢？</p>
<p>修改 <code>Sqrt</code> 函数，使其接受一个负数时，返回 <code>ErrNegativeSqrt</code> 值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cannot Sqrt negative number: %v&quot;</span>,<span class="type">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> x&lt;<span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x, ErrNegativeSqrt(x)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">	fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p>
<p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>

<p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
<p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p>
<h2 id="练习：Reader"><a href="#练习：Reader" class="headerlink" title="练习：Reader"></a>练习：Reader</h2><p>实现一个 <code>Reader</code> 类型，它产生一个 ASCII 字符 <code>&#39;A&#39;</code> 的无限流。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 MyReader 添加一个 Read([]byte) (int, error) 方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reader MyReader)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">		p[i] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="练习：图像"><a href="#练习：图像" class="headerlink" title="练习：图像"></a>练习：图像</h2><p>还记得之前编写的<a href="https://tour.go-zh.org/moretypes/18">图片生成器</a> 吗？我们再来编写另外一个，不过这次它将会返回一个 <code>image.Image</code> 的实现而非一个数据切片。</p>
<p>定义你自己的 <code>Image</code> 类型，实现<a href="https://go-zh.org/pkg/image/#Image">必要的方法</a>并调用 <code>pic.ShowImage</code>。</p>
<p><code>Bounds</code> 应当返回一个 <code>image.Rectangle</code> ，例如 <code>image.Rect(0, 0, w, h)</code>。</p>
<p><code>ColorModel</code> 应当返回 <code>color.RGBAModel</code>。</p>
<p><code>At</code> 应当返回一个颜色。上一个图片生成器的值 <code>v</code> 对应于此次的 <code>color.RGBA&#123;v, v, 255, 255&#125;</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(image Image)</span></span> ColorModel() color.Model &#123;</span><br><span class="line">	<span class="keyword">return</span> color.RGBAModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Image)</span></span> Bounds() image.Rectangle &#123;</span><br><span class="line">	<span class="keyword">return</span> image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(image Image)</span></span> At(x, y <span class="type">int</span>) color.Color &#123;</span><br><span class="line">	<span class="keyword">return</span> color.RGBA&#123;<span class="type">uint8</span>(x),<span class="type">uint8</span>(y),<span class="type">uint8</span>(<span class="number">255</span>),<span class="type">uint8</span>(<span class="number">255</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Image&#123;&#125;</span><br><span class="line">	pic.ShowImage(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h1><h2 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h2><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure>

<p>会启动一个新的 Go 程并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></table></figure>

<p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p>
<p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    // 将 v 发送至信道 ch。</span><br><span class="line">v := &lt;-ch  // 从 ch 接收值并赋予 v。</span><br></pre></td></tr></table></figure>

<p>（“箭头”就是数据流的方向。）</p>
<p>和映射与切片一样，信道在使用前必须创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure>

<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">	<span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">	x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h2><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>

<p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p>
<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x+y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="练习：等价二叉查找树"><a href="#练习：等价二叉查找树" class="headerlink" title="练习：等价二叉查找树"></a>练习：等价二叉查找树</h2><p><strong>1.</strong> 实现 <code>Walk</code> 函数。</p>
<p><strong>2.</strong> 测试 <code>Walk</code> 函数。</p>
<p>函数 <code>tree.New(k)</code> 用于构造一个随机结构的已排序二叉查找树，它保存了值 <code>k</code>, <code>2k</code>, <code>3k</code>, …, <code>10k</code>。</p>
<p>创建一个新的信道 <code>ch</code> 并且对其进行步进：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go Walk(tree.New(1), ch)</span><br></pre></td></tr></table></figure>

<p>然后从信道中读取并打印 10 个值。应当是数字 <code>1, 2, 3, ..., 10</code>。</p>
<p><strong>3.</strong> 用 <code>Walk</code> 实现 <code>Same</code> 函数来检测 <code>t1</code> 和 <code>t2</code> 是否存储了相同的值。</p>
<p><strong>4.</strong> 测试 <code>Same</code> 函数。</p>
<p><code>Same(tree.New(1), tree.New(1))</code> 应当返回 <code>true</code>，而 <code>Same(tree.New(1), tree.New(2))</code> 应当返回 <code>false</code>。</p>
<p><code>Tree</code> 的文档可在<a href="https://godoc.org/golang.org/x/tour/tree#Tree">这里</a>找到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	visit(t, ch)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> t==<span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ch &lt;- t.Value</span><br><span class="line">	right := t.Right</span><br><span class="line">	visit(right, ch)</span><br><span class="line">	left := t.Left</span><br><span class="line">	visit(left, ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> Walk(t1, ch1)</span><br><span class="line">	<span class="keyword">go</span> Walk(t2, ch2)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 异或两次同一个值之后会为原值</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> ch1 &#123;</span><br><span class="line">		fmt.Println(j)</span><br><span class="line">		i ^= j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">		fmt.Println(j)</span><br><span class="line">		i ^= j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">1</span>)))</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习：Web-爬虫"><a href="#练习：Web-爬虫" class="headerlink" title="练习：Web 爬虫"></a>练习：Web 爬虫</h2><p>在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。</p>
<p>修改 <code>Crawl</code> 函数来并行地抓取 URL，并且保证不重复。</p>
<p><em>提示</em>：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！</p>
<p><code>sync.WaitGroup</code> 是 Go 语言标准库中的一个并发原语，它可以用于协调和同步多个 Goroutine 的执行，以确保在所有 Goroutine 执行完毕之后，程序才能继续往下执行。</p>
<p>在使用 <code>sync.WaitGroup</code> 时，首先需要通过 <code>Add</code> 方法设置要等待的 Goroutine 的数量，然后在每个 Goroutine 执行完毕之后，都需要调用 <code>Done</code> 方法，以通知 <code>WaitGroup</code> 该 Goroutine 已经执行完毕。最后，通过调用 <code>Wait</code> 方法等待所有 Goroutine 执行完毕，程序才会继续往下执行。</p>
<p>具体来说，可以通过以下的步骤来使用 <code>sync.WaitGroup</code>：</p>
<ol>
<li>创建一个 <code>sync.WaitGroup</code> 对象。</li>
<li>在要执行的 Goroutine 前调用 <code>Add</code> 方法，将要执行的 Goroutine 的数量加 1。</li>
<li>在每个 Goroutine 执行完毕后调用 <code>Done</code> 方法，将要执行的 Goroutine 的数量减 1。</li>
<li>在主 Goroutine 中调用 <code>Wait</code> 方法，等待所有 Goroutine 执行完毕。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goCopy codepackage main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func worker(id int, wg *sync.WaitGroup) &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;Worker %d starting\n&quot;, id)</span><br><span class="line"></span><br><span class="line">    // 模拟一些工作</span><br><span class="line">    for i := 0; i &lt; 1000000000; i++ &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;Worker %d done\n&quot;, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    // 创建 3 个 Goroutine</span><br><span class="line">    for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go worker(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 等待所有 Goroutine 执行完毕</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;All workers done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们创建了 3 个 Goroutine，并且使用 <code>Add</code> 方法将要执行的 Goroutine 的数量加 1。在每个 Goroutine 执行完毕后，我们使用 <code>Done</code> 方法将要执行的 Goroutine 的数量减 1。最后，我们在主 Goroutine 中使用 <code>Wait</code> 方法等待所有 Goroutine 执行完毕。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。</span></span><br><span class="line">	Fetch(url <span class="type">string</span>) (body <span class="type">string</span>, urls []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> urlRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">	v   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	mux sync.Mutex</span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = urlRecord&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="type">string</span>, depth <span class="type">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 并行的抓取 URL。</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 不重复抓取页面。</span></span><br><span class="line">	<span class="comment">// 下面并没有实现上面两种情况：</span></span><br><span class="line">	<span class="keyword">defer</span> m.wg.Done()</span><br><span class="line">	<span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	m.mux.Lock()</span><br><span class="line">	m.v[url]++</span><br><span class="line">	m.mux.Unlock()</span><br><span class="line"></span><br><span class="line">	body, urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		m.mux.Lock()</span><br><span class="line">		<span class="keyword">if</span> _, ok := m.v[u]; !ok &#123;</span><br><span class="line">			m.wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher)</span><br><span class="line">		&#125;</span><br><span class="line">		m.mux.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	m.wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> Crawl(<span class="string">&quot;https://golang.org/&quot;</span>, <span class="number">4</span>, fetcher)</span><br><span class="line">	m.wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher 是返回若干结果的 Fetcher。</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="type">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	body <span class="type">string</span></span><br><span class="line">	urls []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span></span> Fetch(url <span class="type">string</span>) (<span class="type">string</span>, []<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher 是填充后的 fakeFetcher。</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line">	<span class="string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>软件推荐</title>
    <url>/2023/04/07/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h1 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h1><h2 id="Geek"><a href="#Geek" class="headerlink" title="Geek"></a>Geek</h2><p>卸载软件，小巧，好用，卸载之后还会清除注册表和其他痕迹</p>
<p><a href="https://geekuninstaller.com/">https://geekuninstaller.com/</a></p>
<h2 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h2><p>Windows 剪切板的拓展，Ctrl + &#96; 弹出</p>
<p><a href="https://apps.microsoft.com/store/detail/ditto-clipboard/9NBLGGH3ZBJQ?hl=zh-cn&gl=cn&rtc=1">https://apps.microsoft.com/store/detail/ditto-clipboard/9NBLGGH3ZBJQ?hl=zh-cn&amp;gl=cn&amp;rtc=1</a></p>
<!--more-->

<h2 id="UTools"><a href="#UTools" class="headerlink" title="UTools"></a>UTools</h2><p>鼠标中键使用，有很多插件，比较喜欢鼠标选中之后弹出翻译的功能，截图也好用。</p>
<p><a href="https://www.u.tools/">https://www.u.tools/</a></p>
<h2 id="Typore"><a href="#Typore" class="headerlink" title="Typore"></a>Typore</h2><p>md文档编辑器，干净简洁，但是现在要钱了</p>
<p><a href="https://www.typoraio.cn/">https://www.typoraio.cn/</a></p>
<h1 id="IDEA-插件"><a href="#IDEA-插件" class="headerlink" title="IDEA 插件"></a>IDEA 插件</h1><h2 id="外观-x2F-使用类"><a href="#外观-x2F-使用类" class="headerlink" title="外观&#x2F;使用类"></a>外观&#x2F;使用类</h2><h3 id="One-Dark-Theme"><a href="#One-Dark-Theme" class="headerlink" title="One Dark Theme"></a>One Dark Theme</h3><p>黑色主题，颜色生动，看的很舒服</p>
<h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h3><p>彩色的括号，层次分明</p>
<h3 id="Key-Promoter-X"><a href="#Key-Promoter-X" class="headerlink" title="Key Promoter X"></a>Key Promoter X</h3><p>提示快捷键</p>
<h2 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h2><h3 id="Alibaba-java-Coding-Guidelines"><a href="#Alibaba-java-Coding-Guidelines" class="headerlink" title="Alibaba java Coding Guidelines"></a>Alibaba java Coding Guidelines</h3><p>阿里巴巴 java开发规范</p>
<h3 id="Check-Style-IDEA"><a href="#Check-Style-IDEA" class="headerlink" title="Check Style-IDEA"></a>Check Style-IDEA</h3><p>自动检查Java代码规范</p>
<h3 id="Easy-Javadoc"><a href="#Easy-Javadoc" class="headerlink" title="Easy Javadoc"></a>Easy Javadoc</h3><h3 id="GenerateAllSetter"><a href="#GenerateAllSetter" class="headerlink" title="GenerateAllSetter"></a>GenerateAllSetter</h3><p>生成对象的所有Set</p>
<h3 id="GenerateSerialVersionUID"><a href="#GenerateSerialVersionUID" class="headerlink" title="GenerateSerialVersionUID"></a>GenerateSerialVersionUID</h3><p>快捷生成序列化</p>
<h3 id="GitHub-Copilot"><a href="#GitHub-Copilot" class="headerlink" title="GitHub Copilot"></a>GitHub Copilot</h3><p>编程助手，结合了ChatGPT 快捷生成代码</p>
<h3 id="MyBatisX"><a href="#MyBatisX" class="headerlink" title="MyBatisX"></a>MyBatisX</h3><p>根据数据库生成MyBatis的model，service，controller类</p>
<h3 id="Sequence-Diagram"><a href="#Sequence-Diagram" class="headerlink" title="Sequence Diagram"></a>Sequence Diagram</h3><p>时序图</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>用户中心项目</title>
    <url>/2023/03/26/Java/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f842af2b53478770146a1b721e3b48778e553e03f3c6e9fbd75927a3a0bca3b4">7d523576801f6f045f8677fbbfa672e2829e4947d19231c20b123458f121e1595f4fa507b0e567080180cab9b97db03da672b7e971345bc2d24213fa3f23f16e478326c3aadf58eff4289c7e6637edf1141cd3be46973af5e4d1225ce88e7557427071c976dd301f609f8705a1fea1ee7fa0ee4c9c4de600aa5afbce4a3f8a711475ac7b28859a63fd08519e3fd1ba5a7cd871b2220c49449561e64ccf7665d0d712703cb74691a95785009cf32336d46765f38516567ad8c37b4a25655bafb5adf89114a339d8072d19f75dae5071e774de865393060e940a764d35e945a36b1381f08e11f0359e64c9203c2d0425d7353a392cb2961db00917431f9d80ac9444676256ebbab818b3445014f4afe5016d4e410436d7673b2384a29895ec61b55c9d1ff5be7a09b913762055f8aeb814fe94ae810c9d903fbdb8b3d01629377197120e169d82623a395ec6a19d63fb6e537d3996612c7de0df5059b6fcbbe05510bf91cd3715a8f6ae5d22a64a0a1e44d836699adf258e64991a17d51e477484bd15c1daf02cc52a2ddfbb51d0513d713f1f877959c3efb6083fa81ff5a327cf57dc1075154a3bcc174e89df099cefd4fa28e5892f22a2580a27edbdf3e984910819b1fd4128c70d95e806da50fe60fdef9ab44c8cc83bdc5a40d3bdd2d51f986065727b0612638b4344762af7e27e463fdb5eff62873a0b2bcd3a7ca12af2db0bfd352f4a0ecc342e3e834e76299ec5aac19d17b28ae5bb6eb17791d058c5b9f77ac7671568488b398582b075b14aa59fa30c8663be19f1ff113f535a0f3739dd6a4b3fb1729dc07072d0cce8e677ad08dce88c0a923fcc038f4c982f868c3b0386843bb6c2254417b172c15746e99533a8563c6e14ec85aaabf4764781b98c2df4e79c3a591326b7e12db624375728eb7c6aa46991c295f1fac7043e01341ac24fa69b5b5e24fd9951112eef67436920c1927422375fc2b67881974d36ed981323b5e1fbc09d5cfac8a2f2df09d570de0a9429a14e59f58086cfa23449cbe472df548b84eabc972aaaf8125d1cb7317bdbcd313b7dd8b840168e9bec85270182cd272bcb8a8bcd3168e8fb1b2b7c632f374f3d539fc3e5552b45e5e81add0ec5bfcdcee197153f2b7f18f648c2abf0d5903b7c2506e2af57c3b99bab34497b20891d5491f67a3594ce6d84f7928a59ed3adfb511a531e03c143ce6cae172de518bf843222c122f65873e8bb77eb2f97ad49ee9d91a020e0a9e2eb9247a545cee440b2a79b05c35b314994b3e21f91a03a263909ed883457c3f54c69c6934f723c6d4d2ef58c5d8a041866e66257b5376b492199540301c255375c7e76636290bb02fa7e38966e4ffa800e80d6b46fe8bace3f5bf7e92e122ba14f6f0953f6c56697fe910f5bbb66b67664472dcbe8f7bf43e553833b1737bf7227ce238cc9fbcc7940317ba4dd500e59a5b5e0281b836834ba785f602a4c4d91b2049c261b90ce921c99434df0b1afd7ee7aa70092967df5cac988be7d35c5f8dab7279e743d8f6c9499dcdb7ba845a598fc8ae02d6284d18514a4ed7e5c6db15b1d792bd4f16c7f89634ea38cd35aa3df018475c87646f40686437aae440ce88fc1b9497dac2981c1cec0f8ead440a6a370d2f2ee64c1e300773a53c1ad1561e3d8bba2d9e5580d67a0106f3637881ef4cd0389c2b66ac7f6437b1ad27ee5692df0087832aa6f06aa5e89930ef07ead623426ccc0aafa504f60eb035977718ce51e3967675312f2b6bf8b847295bf8c8b1944141c53e5f7ab7b91fc696df42dc97f3a4392be7b6fbe1cbaac11e47c048acaf5378205fc0715e5cd16678fa83c9c2be5e3fc77e721eb2175a21de58bce23fc067a4d37ba246d91277d04c1dab069999edcb73fd3950b75586cd4a44d8f4620f2099c3ce7c7305216f25b9e847143ede03d2168725f6abb0e4260695b4c79d23932f9c04fea3db4c0665e9446b53f2d6099ccb6805ed2762a64505901f425867eefd09cdfc851ad44282d5a0346eb116db780973dfd4d4d0bf7116a7143b5ae0699e05852cc2044ce2d5e877ea6d15dc159fa4cdf8e4a1b41185f834a353782227a3dc205b84730cde22e7926b99d819e013b445cb3cecbaa8ba029ebf4ae8e1d9a41bfe21798309e9b613bb2c714cd2134d4def872748aa9e7e6cac227e005dffd32b58ab6a5a1434ba4953cff7e0e26328d2f644fa3279d74dadfa54e72e2c4ac0556597beeb4e3e5b6e72ec7a72e0a0ab7593b2f78100d84c7f58471d5e81987317e32ca0ab79b29a39d7af1f568790c18d4bb907fdb835ad4c359139141dee4d69d9f30fa248c5a943e2c81fb805d56601c2d4c3d1d215e20ff2f70f76d24027fb7639e9a247853fb394b6ab77f3eb0a5458e4dc7a4fc64da03fe0f6142b3f04aa02c99f300647ca8e6c00685656cea15bfd08207a00b3a42fab40b39b3112e8866b8320098e855d5521d1fad4d1bef91d09c6648184bca22c9712311b5bf581c06a865fa68ef1767f76212f386d6f790130be7daf9339a94aad7d2ee1138ac50d61f00dc9c5e529166b936c8e88d4f09b3b0a54859434527e73d1751cd1c7e793ff7d206744f6a2dcaced2eeac7c73e91921b70dc928b05b34264f8221eb63add508c890c7c742dd235210717f2b21469391f1588055f24fde840b72c23ad4ef5ef8289848f287406a0d0ec77286e618504d8024312c6d889d8ec6a69c309397fb35a9e99eac0e72d1632378b11f72cc8b6c898c65d42b45f3afdfc618e2a90fde47fda0a81ad33cb4aad875190b41a42cb98cf11c5f6e3c84db072e6c85c84f54a701deaced8b0a35b987df2e3682d90f222c0b6b372f5b75438e083c9ec0c66ef8a63c1b6ba5330c1bb0089e4f660d0dc2f027bee5d339e1a3a6fdab4cfa38aab5dedcdf2fce21431ca2433da03b4ec9ef281dac83169a38bc40dc2e443bf5564aa7e3dc815db3e57269025bbcf2bfe088e44b8dada7a69adfc4bc1146c80c311ebd049eab6d52cd0aed08e9041dd58ae0088fb1f1a8f612f29da4cd723ab5530855c0761cbae58e079525d042a1c5d257f6415aaccc989c1ee93160aefb112dcbaa72f321a1ea686998f970f5aad1f402054a65c4dbb461321986f82301973e7a362612dd3b0814beddaf77890a7118ee40ed6bc3e3a2fe8fcd6d2ff6b0deb4a73c698aa7c005572f09ef60406d1c05820534157249316e909780f4aef2e48267542a07757f25afbe3c7b25540cd948c81048cf4121a9133ebe2139198ac16a23ae703653b8fb871c1f8d57dda142ded949308ddb79fe6c5478365e59be37ea274d416173ffe951de11997e4ed808a90a997bccb1d2d65bc9d2c686b91757a98fde89f371e5c56d826e3b3a8ef17b5f60677ae2e0207b872b4773a1bca5e389a2d7eb672714c68cd345f7f1d8da92004513f1e1fc0942dfe2859200a9f9bd0157983e2e0018620dc8b581f0dba5ab4a9c02f3a4b0d0a64d6485fc50cfaebbad3f331f2bebcbac6e250ea8e142ba1388880c7fbe0a560dde0e93b5a4e98e50314af0cc8c18668fdd370aca79d3d7913b09dfcd8666543cfa41f650fa3328d1174e20c52e8f603927d2650d24abfd376bdcad9c10245175a317340448bfaffdbdf5923e08720bb8cccb13e38568bbdbe249823311059cf6a6292bd7385479c2993f29f8e25753e8c03823621ba1451c535739be4030b3090ba1e2f04e2fbe8a8f40fad1b834e957f3db20a215084826ec58f7983816b3ea4e81ccfc5b566528cc85fc6ee3571c91787d3500b8ad04bb7c3bcaa0c8a7b03022ccafc93ae9c8d2249434723fa3075d5656ed3c49614804a9ae2d850160cc1f90b28018ec7c4453a6cc8f5ec690ce6f8558c3ed3b6362cd7edc1b9844ada6fdbd1aafa400a316d99e176b010dac41391bde88e233ad03c2aa37976e169c6c4798378e8c627ab7ab42888a4f1708673a4ca0237d63d2c317d34b50507558e5d28a7b2ed69df21d93df53682e13b6de8e6daf35c098f95cc11805a4f8268290fe162d3da34c6bf017126c20584c3643fae0837db709af36e0f1508be30831b06d2676322119825974acc9910334de0c28566b5f0df9d5be8c97559ddc34cfcf78044a074bd708ca8b51ef13ba6d3fc40e916a05d5d5909f50d386781111346079096ec18a132c44ae4a6b8f4a6390e41ae0c9926ac9c31c9ad325f5116ac552777193da30ac0233d5263385aa3b4772093f7ba161db44b5db508b0f2a14de3975b113b212996ff172792379748b3035246f48f8445113d513898bd7ac5cb4c07ad37e8d521c5837dab21b4ad6bb287d07e36482c5549bb87112ce82ecb3433a5e9e3c9657cf70f757b2386379fc67eee7eb43f9a88aea311a5040bce1c9164908dbe10216ab44e02b999106b454cea121f7f582df0b5f1e9518f650ab0cd75d426148197d18d2dff8e20295551a10e00fbf4247c825f5f5247cd71e62b58951b9355cd02b75a096b5bd5da9bc28d271501b6fd43151560e16c15897d9951b97c71ae2f0cbc4319b4da103a37ebf8622736f7546ab8ceb3c925d0dd872aa1fcf15a20b5c1dd4a55c5ab5bbc7fc8adc28ed3356d8d10785a088d2b1aa60e5bed44b097715d45d71a60ff2a5d93cdca502bb74f70982b16a74b870fa1055e0a158abe7d9389f0e6f1df4bec8a5cc7a57b9ac9160b9e5bcd1d3f32b32b67417bce3651c6614f0d16f3ceac843f75ccc3b044f6e015b689dd68edc2f04b30f0dee022b3484d15e7daacddafc51e9499c53080812fb8df0eae92fab2974b37d7a209108a1f6765b51575ae29de15b5e858ba2de7fef0ac74d9b609751f978d53d9a2522e5c1bb3ddcf2fc018a5ccd30b41bff9876462009a14439ff0bac0678834e97d12041bc27c35bce71f6561dff525e813ccb707cdf8367ec0aa1019e137f5f0c1029c3b64640e630c014ff8ed5711cdfa6aa68adb5cf02c9d17429374d0e6deae1017e70ecd0a8d6beb0789a6aa134ab13c97ec953a318173b76f17abdcafaa671517cca4ff68a60724e8602dce5504dca7fbdf6656b6e24b7e21595480bf48f07f83c9eac169f9762705a4c91f15d793724b0b850cfcbae22d4f6bd895a1e5ab87c1609a0fc0331a4e02a155c10139e7b71dce679034b525230a8de3db3421b87a97247dc0409895bff6b88c154192c926a964c788d5453aada006fc049a7a285fc4ce1419fe99dab0ebc45784b2341dfac2568dddbc1129c8a18ae19885d29b6593d16526b9b2219a41e93de5b20b5a68af162f3eb013d57147a7940d6b0df30bcb7ee40a99bc1cba08ff55eb854597ba0f5824646e9b601990c2de0947f3e161c7d973001bb4dadad3b207b9e153d8ecbfe145a5846faae4dc65af8c1a956135ca64187b5d6559821a45e91cbe850f8308f908aa928c307bc928eeddb063f183d2257d4d32c2ccfb07f1ea1a6e332fdea59f53357489861094f48ec29aae845b7894486c47c168840151e056aafe66b123f667a33077e62aa2dd73a141b6a4507cec5202425cbb07e3fa8ea67e6aa1e6f0dbe8bb185479073fa34663caf6bae073c814a94d02d4d6edd04858f7bb08026cd38362d09d2537871a92ca27537ed57454e71d72f1b8410d386907103973770df963b7aa36bf42cfd7f07dc1709e1a377cbb2c7a50a2f1058227b763b346930a0d906e5304e116673e35781477343ec011fe14aede2190bdd5bb4589d7a7200f758528409e581658c19a295bceec772b848d73ec002321758e83fcfa07ae131c519ad94d2f0a022ebadaa2cb78b50c5d9211b96d195af1cc7cd0fd1e49e1bce17ccb9ba07d909ca15e47ce592cd9e94afbdbe7cd97e456efa5f6f652e8fe963d78eb47d9481eae27051fff0a3846a548f13e3b164d1d733445554373e55c9e8bd282f4cebe547912e43f893af4ccb04fb9d85e817b3cf2adf82b9979a4bb20f001c35265219bd70b32c9abc3db62c10805c8021004b3b4f13d8e9a2ec20d2b42396a8e6ad1f1309e4c04cbcbba7b635117d33e4b221bce928cf3aa848843b56280afb1d2bbf38f49723e239ca4722c2138af1039af70eb298e656e6909bd6c7bbda6473c5e959fde8b54447f433234679d2fd164a5ef6b4e109b7687f42aed7a331794cc83b5ae518802413dcc5f4c7580d6edcb2d3d4dd48c50856abd2754d5c7973be0b33d2812994bc70bb7124789ff8092747ce8449c10f5638360154917a96a499f6f1c9467c18bc25fe91879f91e0929496ffae53a4b8066af27cade8161af01fffa73bb153c94beed8a4be65dcd04a3f18951bd90cccbe599df1023a249d3e93db11e59cfcf6d903b636cb8f93ee1426e18068e29808ba3079fc05de0d312052f21ba4db3e9c2f2ae19485d0d30aba124b137fea5fea8579744e3bebbf49104e955a8d80386bb0bec9f7500f9b85246a8185a5465ef317e50d17c9a9db1c76c8e4f7270202ffbd6acca0b40d0042797d12ea7e6087598429a05d19e2bd6d16bda74ea764be346333783a8ca184a3c9266f74daf499154aecdaf19c9263f8f8e55c0f58b270e3516617b341d83666f5918fac8f4b778e234022898cb1233c00889fe034cccbfdeb2a17af7226c7b6e069274880cf8945d050cc84fe242f94ed8c26351c7552a2dd7b7ff867b3a2bc742dd4f74ad9902a1cc0715c1068bd6282c1bcf315450eb459d8d63e12a4aa9c5114d3a65150acea682fabd38dced7fe92eeb872e15c5c1e4808ffad40109b3d7331c0e4ba988e241e0371d462d8a2d18a191b6ff08a806281cd64e7ef9b978a8ed79cb8bc40fa5fa43a66ca92e65762443fc3858f50df9a8d3f7c211706b4af5c5da608bbc0c81cb1353570bff57d03765efe6e684b5d8274df7f835e913000e05e417c9bbe5c92eeef751a09c07be25da0aec17fa261ae0f7ecbe1b808d42199f97b6bcce6badf327563f9303b62b1bc3929bbc3a971f02d55afeded0138316c228213cbd8bea5bbca62a8f562884d38853e95039b6a1a6092d2d1c2a94c0649eaaec66eaa26d8d90189c6014f8b1bb6577c866b7917363f1a57a3d897e1d16b55c7fb43f03cc04fc84ba94d9d76e860bbd28804b415c462f3b42b6640ee501188b2b01a13faac71c019d3bfeab1f212e184ce420cba6888489d7cecc998e749e8beb53c0ae1cc202b7c52912d37213346ac264ad281e0766cbe18f8404046638a2f9071aa15a6b2aeb622708cd9dfbad9ea85a726eb9937a48f0ca8c26ebbc8236f3fa91c300c6583e2016342739b4bd434e8ce7e3dc7025c0081554db74e6d7004fc6af96bb6983a8eb47100f5b79b4118f94fe9dac081f2de13c30c77d97b4516f1bdea16c6f55ac38d90c72e7021b23bba8a33771b7647b91ceb05f0426a64edb80ea5b23cb88a906d16f66e1861dc21d7cf3da04788cffd24c9c0e94d2a9d50a5bb89d9a073f4a676c906aac1adf4c03f10351f08d77724537ce4b52d282bf569e20b97fd76c12ab9bb336b37e389bde086bb8e16c9c71023a7fa58531f794c08e3fb8d5af546a94355330cfdde665ea7b09d77c5ec75f5ac2a810d2ef9cd57fddca81def5961787ec2b49f0a374776621773a2485920c576ecfb272e14fc52f88981f189a972977138d112dab2d17fa72864c1f6241d6e7ba7d0176d4e9e39433976574adbd8b45941246645bd138db157e72abbd8b27fe0e2709b662e87399aa481f80e2afc85492cb58525dfe5554adb0ec5bef07e242e19c95a6fd36162852bd4d9de944a1928dfb9ac2663718ed58e888be3c11db31b58090cce3ae320e278cea77859c13b103840ae65be4a0b27600a855dcf2e3d4e3df32e742f7aca064b88e12cb39a35884004679c0126593a43aca12d9ac45eee23ef5c962400980a2f646167b39a10fccfcf33fefa6556dbcb8fa07b3f71669bcf431179099b8085cc7e3addc1d1f47786f2b61bb8cedd3b3bfb7d13486bd77d4372d37ce44750424ea494ba9374d10309905f8b45ba8a2104ca66b42b10de71cd6b07e3a41481a3254c3f922b33673aa599377d45131ce027fa0ab6e30cfb8642c2729c6dd33a4083a080b22ba8832baa4635025a25dcaa6901f4cba76482664626294d668df3ae3337486589b1ee6aa3b5d8258165b84951761cddd751d3311830c9424ed0b1bc68e38af92d67519f4d7884c1043d7eaeaab7f1c74fad3105a17ff0b79e793744164364eed788f20654363f7812c0597b17e80f47fcf4da57a5f33f6d0031985d8684455ddfb9ba1569da14f36db6eb9a0388e8c5e91a80460f78cbe389d85525bbcf0496abbb89942f8a6784bc868b87dd6fcc145b9c08fedb30952022e2d95eb9790a5015bb3a20a1d97b625efe8b4725690ebb621c00be5884463850059c296a0e5649a1dee1cb4d449894463258bf2eaaf45d86df209fbc5f3edb183096f1b4b423f4041ab84fc7ab08af7722c048f882ddd1e837a22bc395df6974250052e1c86a89e76b58f87a2a8524fac532403b38aef09cff9686c41e95d5b483524e991cff9389d5e63262f4f2ff0ae8611aef71181e17f75a82114e6b7adf87ff47e3e1a58b0cd67cf5b65b2f73c32e14285fd70e0ce7dcd60f7b0b809c917940b47f99f31aaf85d1ce0cc11c5c7b9838045454766d20978dab47f9d0d35bc6b2103785f97a7c163567d2d014fb9f9c2e7de776cc448bcef84f1dfb14115d56a6eba5cc760d5e225ec2bfdcfd508ede8d738d2cf5496d3fc7abd67249b3aa2e6593472222f618bc0fae83e58dd13bf916593556de7cc31112327456831a526fd283930feaee47859debd3b74d63d669a3365c6f8a0e2b9c8c36e4c783515592ca6b29fb456d117394971df606fd53be1490e3beee3f21024c6350cbde3ff8d54b0b129cc58542f170c319e1006bc9d8ced0b21c13246fe8c37f66205e82414986ca005900c8b5d403b805b365719ab5ada8dc27c6dc2d09eab30c1401028c2b3f4e21f2102cfcba5614002668b1bd9d37606b81e54fface5cfd216be7ec3d99352ea86908137393101da21805a1d14b9fe6ac179c2c69c69f9d7e56987de0a495a5c85eb6c37f1d5e8e3120a40789907cbee8347e0e8f33240c71a2085d6eeb8d6c4fe1f342251caabfe160bfb74d702dd2057e09c33ecbf11cfee88f3bc90b23819b6a1167a6b1f4a0077ce307faa92cfdce13d2f0a095aebc8ff84ee8b6165d5f28060fc67aa5e6f3096be6bf7aa8e464b90935406e452ebe77e3261723885d3e22d43b05b050a31a9e476bc21b4a10bbbdc1f6fbc80cdc0f7bfd1dc30cdcfc7f84f437471c90e3f263f9071ecaf94ae79383f47daedf070974f453ce8882f65cb622a47d976f894b8cf3af24183c22b9a034568797ae31fde9a1532136db7f2c9ea7984b82d31645613371f84557666108bde7f5663f0e941491a57b4f04e3757421f8b25bf0bf484b939b3b43f9a0b553f33d46533d0c1986d983525ab2ba1f4ca00ca88508086c04545e865be22d5d7c5840453cfd593caad2a10326f27e96c46cbd9754749d9dcf68c6005a5eda12deaae41532a7e8d911dd59116fd51bba82667ca25285ee78228e8b3a9b9676edb038ec6402eccbdee592bd45fdd1975782705e528026cf03f2c52fe390310155c3f61bc43f83658d93ec53ec33ecba6fe9a67326b98a42d394695218d5dc4b838eade7e060b0cfa9482b5705e1ad56cc3069f4ab3deb11a8557bc98e98d68a883dbf267c69fe332eb1d171d681b6bdf6e03366b4464a47233cbb83d959d3ebf3bace2664b68deeafe090e09d2dc473bdc4754f67cd900f03bd7c40b26c82aeb757284ca4ab8cd57b3c6b87a5090252c943a394469bba29d2a9bc7dbbe615af03d669085604e9544cec94c442603400686f9a45961942d3f90c0d3cfb0455baf2db4a608740c140438b867b218c5b9a00473e629af7ee21771c30d5f0d72c2a068c11b7eb50ff9ed5b615fea0e36ed48597ccf324733e5257b91f6233592401be41f8d33706c4e24c1d3888862be452d2dfb9efe72a5c4dbe7834ec6e97d027f98342250bebb94459e4d8c9e0d7154cc7865d35f25d15be93da0b63f96f299a556b14ab642761fa680bd5dfa49d9b7c5536c9d4ee35efe96319881d92ecb552a8bfd4d7f1c3b6cf8507e4184bb05c7cfa2e04e2dc5750c40a6c213a36978b70a9d52ea00b2305d5ff084c170fcf6dc6bc0e82a4960223eaff06909c7e7b8c8db84ab154e397562968ae98bf8cb239c8c585eeaf5ca78abed6f3ec4451585c0666a0f602242f460ebf1ce43c8d83ea66b46e5c8612be2602136b15e0803ed8d3e494fcb5be739f21fdae30afb88487c364ddd9e2ff74aed886685a1fb6b482d395fcddeaa6f1aab4fb1f81a4359409c79a6bcc3f4ac9eba1a595c65bfedea9cd5462cb3c32ed55fffcb1615a2961bc539ff6621f2a7c32863d59b367cb8d256e7d28349f07e92b20ebec2eee0583fc4bd2ddca2159edb771c17bff0d16145fc011969caa2df956760d363185e555a46133b69c20ccead9ebd6834a38562a4a5d5d2f6d2b7c8c4169a36751b34759d808a9ea3d886b7cc999ca5ca061031aa12a14c1ea9882c43aa811d42992dab745c2c3a79c6817ddb53f7c8648831f6f1cf484dc0d68407c17246438a08372446478261205c9724bdeddb6ec33e9657fd1a58588bbd876e81574b7f6c71ac297936e3b067d27d32250856332a362d6f3d8c0c2b6c6eb773699a945e49c314a460f627cb0a6e329550134743ca6674b6b2bf1233229f25fc75b440a48e0ae126547e271ce15ede815a24a92b3a9009cf84848b0d236f6627ff11f9517974a976706592ab28ca648f8c29225a968f0a88baa40ec94c731113ae501a9edd73320a46ecbc7087d9f5a5ca4356cb13678763f1425eeb2df73b608e7825de72ab96ad02d1a63c9934750ac1c78b519122dc492bcedcc9447010416f0f872eaed8dd55f404510d8f3ab3d4b5c8503f4cd78073855f0ac6a43579497998611cb8f30e4775e30d2c7eeda6995a4501bd55b16d3875b33f648ed44ceba01c2d4f8c93406437f82c3c610b64dd0fbb578b121c4eba3d389bfab696ac68ffdca51ce21016b550c8e85c4c90d3480391d13d4a87e38c63fff60eeec357e83fe78e0953d8cb7ca8508dc389c61237b20e713fa65ccce29a03901972048614159ca715ce0f28b70651b095acbd1d610c4c9a8f597018767add71b9765a6ea46549e3773adff2e9da491f36c9015210d055eb42d8c44d16d3720ab29d7328661d7fd42c8f6eff03799384b9f550b45d52decce7accef829695730ae73cb0d859168acc1258ef02d26bec39a2110456a161b37f568ac9650c720448c2853ef6dd7d53c4814592106b43b29593b1cfa682b59c48cd0ececb96da7df2f2c6131557d030c477a0b676e4a4e4f85b9bd57cba6f563fc64f6d953063971b3b523433c27fb1750b283fd3d52f34a7e71d541a6982e1621da547a376b9246cfdf7dfff5e4afa9fdae3cd448091ad6ad6c46d77bbf2512367ff9d66331b236f9802a46d6a2dd0b52f4e370f0e657dd0824db3df07dbc6c31648ccbabded16a0d7ffc40689a9c824baa87e8da2fa0e0b3a175cff7f60feb75480d932bbdae39fae92152bef7b6d0e6115b20172fdae4bfaf05dc2eafe3d7265b746d446646048e283cc563e0857d629c6e4d673368a3b6ebf2b841514230e96c97c84f8da08eac495fb36d06e71fee64ffb13a1d34b3d2a74ba2b1fc55a63cc25ecb0e24caaf8512cc5462dca65b3b290ba2a8f082a660aee0dbd43e4edca125d21294b79ec863dff1d6caa9dec5ada22486bf566130434dbcedb6efdfe4ca7bdda54bd7a3db5bb3b52a780fc9c968b2262b72ba6304050fb9709257bf58a0a70ff56c37505aba21b0572cb02988965ffe2c46acdce1bc8a737040602ac42d29e4df4f811d3267b693286538ef897eecc8a008959116898d4234c6ddba765e46922d58f706f91b8e0fcc2eafdc6371b7b0990e32e4d16ea1a5cce298f5916de2757f3cb8975c34a3de7f735f1121ee0de09577793952b1d94e2e16fc2693051b62cb608a31d38e1e5a1dd24f068779c04d875052f532e85caac45a2157324365c82d58e1d532bdebb63e636eba380e8fb52f210bb81685900a1bc45c31d784114d95a9adeb01c1933eb0a9271fae49ab10bfcc23f84369e899866b015e5018a5977166e8aaed060502d69a25806147b742c24856d4a89a0407edb56f96e861f8648c2b4effc2ae5ea4f1cd1e6211fdd170d7e38152748751e9b46e74a998c5ac5d060131fb17606b0a75392bac0730028b3b850c3b1f3b24ffb44775bfbd5ac1f8436c07dec0bf1c10034f3030d181ec575e752eec0bbe77ba816efc2dfd16b7b5922d68fc19709d2ed92847c91864bedca6e2594dadce422adfd853af02e9f30bdecd193d5ca9fc057a22178c0ef0b6bc041fada972d9172ae006da099933593a1e76fbd143b2ca59addd357133b53a6f676030ff48ba1a8b588820c8d036f38f6ab158e5932054491805e0b966bfb2bfdc66135b7ce556f5f32343f57f1bd95ca6be179bfeedf0fd930ce2b7cbd1b9accd63adfd7b5a09c8ae1506fe868c2d740e577ad0af1d473a62e6eef4937b9dc3fcc10bdaf2bef77d92b513c20d924138f83da9681974f3f143e347b84819571b76cb669507adf76d37bab9cdb1f8492b4f131011838c87744e1534b2562def62247b71e6a98109de35d835919ecebbabaa0037b83314290a49b51ea117d710ba366f7088a9b57c0395b34f88d48a4c141a6093ddfdea45a88a1a2edcb98bb30242a5c404f8ca2eebe20592af19ef5c67f7a53366d41a487a9760f5710f2736a1dcf978f62e4a61b9f7c880e51c737d89a5d1c8594929eb413dc4ca48057a77e76f4aa87e9060026fb6974d5e2165322f2e9f9c82d5dee11cdcf0d814c6940fef78460129dd98a594dce28efcc75d51dcefe826f70f66d00344d5fd05eeb29d8cf0572a5cff4e1c53646da33cd91f60f14603fdd41a1f00e8e633e51ca562f7e374bf8e83955b7e07b990d80a69b3dc0a4920ba14310625b000d803920fdf7d1ec6e563685e9fd5adb74f9249b1c528b71bdb0c479eec1ecf81ef3fb5bf8079fc42e36de0951a664e23ccb95fcf656207b92a6cf6337486dd7c006dcf676f0ca1e505a478dc60a6e803118e46ba0edf7352c94ff63dd7308694672aeecd2b4574bac766c147e37418a11cdfa2207dfa0756f9f1f4522c92ad2217cf6c5841bbdd59f59278fef7a50a96dc290b16d2726862e6235875ad19960f0c8f1b77d5471a68d31f8c6c4582a71e4c89d8e2355f146483479430e91b2348a839654a07bf5b38ebc14d16f75e007c5aaa9c5366d91935d570eabca5094faa6c6b35ab721e294550647a90f28f3e7b8f65bfc476b2870c196d07f664065f65f9a5a3034f303abe71da3992c9ac921c914c4cac834ad593dc5ce131bbf840312920bbcf58a2d41f6423cd651f46a85a14b4cbcd4625f3062ffe18d20640f2b3641580c077f812d4d9cb5b75438623497b54238a68cc893916cd92233869dd22368f0cea290996223b4fc8c68512f2a6921bce8e752392d764d74bfd4ba41c3b397e186488c1bdcbe4c19fe0e7c89549df7a3b71ef3d022719b7dc5876e173218a7ed2c545826acd20672ea9a41a3daaa4b116f147f2cd2649bcf02b3f373f282e7c346b4e2659cd5b694823de6b8e13853f2d8699e0f2c1a3af3438389684f501fb62dab856a6cddc2229725ba60e69edaca23c249d1921d1fe59509e979520ec5cd075acb4d24197d3319e983d9c517d304af194d4cd817e3b93cda6f862055234bb18178e57f877413d28d2fa92c04b096387528bb5c06d617f6ac601e0c86effb0955b3f795decad56fbc7c28ed3adc76feefc76f4ea2f3b349fede5bac7956227b2e669f626016ebe70d626f9c62d27bdcd53b2989bb09a1194b8a641c6a2224cbe2d2a3879edd3966d1a31cc6272b0c2d34ffdaf4a62225baad0769e2edffe540017385a2ceb8914181c8a0134d803a112e876f2f0afd8eef4ba7ac38395862356e2340c9b7f872782b78e96a1fd7e76c3f293fa7b9df4373c4b2c1646ade5dec2e5772badf676bafacbba3d8224f8e38c93e9b67bec78c79de9748a181000395d8937e13020a524a3d1660c94a08410cb04f73fbb62d5e9c1c9b93786bb028664119e417d3ac97c4aae479673be05296dddaa4c28e55ff27c53531a0a1b96fb1888041cbd7f505ca58afb14709bc6a21666f17c6da72ae2c99e4bc30ac09ceaaf17b8a2c9e5ba0ab74a3620940d6c8a53761c18b7e892311d3349f3e0cc4ef2aaaaa3927d5bc708dd29bde67c7c4fc351d30d6f9948c24746948f0bce18c0d5e27dc5ad2e664d44eeb53b404d5b650ed8d8d1e59f8e5756db3bb73060885f97a4e83d68195825560b7bf398c3674a591ef3199c89aea05aac875fdc11cbbd563a2bd1b5edfd5adcb28d0c32d64dc3c2d5a3c9c546c0703dedc34677077cbb15c3b3eefa48997acac725666b5d22146637dd98a12d021bce3f406639dbc47bf7313cf209c8d834765bec3ac0303e033b2f5948ddeb62ce8a147e859ca36634cf584d3d7a19ea8c25e504fdb7b315140abf64fe30f4fb3a59fe41c2aafca7ea4e8b7e5cc8c08e935d777a98470d831116a462aa31d7824a9b828f94b3557c354295861a5ca3adb5b97248d9a91fda9a2e8b6e1cf879318ea96b5f486149280dd605ba7ce33caad9bf393b2474aad27d1d6e532e78b3dd91994fb0b183d2f81969b3d6beb389d2989859442efe1611aae5b065e73a63447aba90da56be652b254738f059a9babcb181933ca4ab8b94f6f900f625e91dea7617fc5ff3d402d3232fb283db155feba81ad4fa610bfaafffd62ed1a3608129ea988096fc2acb0cde05a6084b24beb03d0c472d2926b5e82a32e981a6cd7f7865e1c716ffa4e537880bb96423c491692da4faf581d5078b87ea0fb359ad237c7dc16fff3ab5f39467884ffa46ce05f5e2eec2524ec9b12acf16bff8399683380c9e09f1d3961c8c1d5235e98df5d6b11e296bf8992e5efcfc82ac105487c9f308d870a5a59be4fb1b6fd802fc348b8411c4378bc97a3671d879aa97721a389baa4cb0cb982f788cc04da914e08dbc1440532ab8ed924cb493b0487432ae777d0d5e545ea2facf54f50fec634fb7b20b741b22adfc85eb0fb45076b470e1982b692767768aa1846d15a043967b42cef15189a655b9adf5a019feeecba2d050b69a0f0479bedfe949182e3826c3c2003db8ec1f2f488406ac65a1c7173cde7e2bb5a59046237eebd87fd7758dd889554128bb2693b52b12f41b6906d45fb8be06507250129bd58fa4ec29f659bb408f0049ac3bfae6dcc6fee3f7e6c02229bf002aacbd55824abaec08b7a6206404581dc7a761ab1602b25a88fad4d58860e9fbaac029fa8d5ae7abc2c27f2ef008090a1dab280b52da2727b7d028ac000e4f99672b1aa9417f90b6b39d948eda2b18f6d09ddbd04062810fba6a7c8895f04245535cc97c9a657db0804f7f0e4d09398eace6701cfe52b5fab2d6fb110adcf3509814a0e1b9b9b65d2956cc8111cba184cb5dff4ef5f2773b44bc1f111477e3710d8a0e2dcd10c8bc06163eab78cb1826aa9e82aab2905a4b487552a3d8a4ee366e2195778e9e18f9645f8f015dfabda56fadcef97f223947617e0b81d96a9158e0bc0e5bfede9d3225971ddd08557e9ba5f4c9771fafc65585189b5d015e560179219f6e27ca8c8118faaef9a20a6f06763c50fac67961c14c9a93888f3b6ae23f279263eba9232b71a5fd337b8c012a684dd089ca9722fb3938facc39563cee41f29e26cc66f1ff22a2ee480ea75b59f1c77ff43e755c9a7638f31bdb9bdf05516bd384548dd191b575364981209f24edb94a1cb663fcdcb8e5c39e11ea399aba7dd980ac057d87431cc3f11dc30d5a4300d3b85fcac4ea2bacf270624b201b676573daa71186effe16f3bdb9b5f3ee9de9d46933ac876ab0e5bba664cdd14f91eee2b7fadd8f3392c2dccda1d82b5922ca445249f3dda67e0435f4487c01bc13ebd6e1199cde7a523b28935acab15cc9b6d056f88554591ef0d9f3cb5eb9ed1954d1bbbeed855bb97fc5c833949356f336343e86c53aeb1837115fd9d948516c3b5ffed9232994e5c965babd3bbe4ee345264ddf45a665cead675543b0c61ef5bd825a8c644195bf6d9e0401323fb739198bc5685124a4f9b3b49fb6f928a5323ca9d892a6a3db3444a9e4b0ca28c88c2928e05d334dc223c3b21809412dd301a47def15e701e2aa3f83c99c57d6d820546638e84a23108e88937313a0c2a1b526234d2da1aeb1c981998443b3d190b83737402e32e37648f5105b52ad8d90d6e57e60f005332ef90e0f59251a8aaf2b1f71ca560c3251ffa96372be0ad0519220049d92ffc4d8314eff62adb55b735831227fe352f82258a8213ac7f6c2c256373272e41fa6268e3104e3fc268a71ffcfde854132d19b80e6f158b3b409cb60917f70c0d377bb851b6fb2bd8ceb6b2a8097dfdb49804cbce32b86948fa16a997bb0587bbdc84d506d1b97c391bc1fb766f8c6bcde0aa777e197b7dc7757d6d52210b43349938d6deb0a9d592e02836761d200c7c4156b111a5e108e6a19e84aacf36922457423d3e5cdd76713bf496a43f33741283649a5ab4ded1514bf421fcdb47fb63da274a1c31d87d4de80013624e3015d47e50feacbc849fb7848720af1ae7e125d41ce32bb53de226f3a2ad107bcb9cebc6c0c6c6916e7da725dab6e45b375a0529a7b8566333dab1bc149313061755d1c01a72db88e440b2a8f7e190575cb2f5e7bdcc763f26de5fb8a1af41cb4ff786a1ea9f1d48578ecaaec2361841201601d8ea4457a90e7f2ba283686844264a2fbd9ba011ba815102dc345dba1d742ac84c0b4b969f058eb00d3a4f7839c9418c557f5df2aee0d4171b41e74ded3e70c033f09c0cdd18a8151e3f6ebb9d5ff3db27b80d9dffd47d17aed5db51bba50a6d300d1033cb984c50cf58074dbc2fc834633a8a6fd11fe3fc650ff2a05f86a06acd3c15b2a5658df056033f45dc22b6034c201abbcec38a533cc522b0293bd2ec15b39d5d7a384f6dda194f7d8f2f52d44f79cafa28bd7edec23040ba6f24aab161a99068542c28d555cdf5ce96a992256a3e2b2191dbdbb9c62e2e0ac8c80580af1174ca491498132606c952afa0de9c35438c4be8a2386f19855556e0e5dcb67fe7e57a3c83d7dab0e5b0a553935451dc0f4296c76e031974757af6855500e8e3d510d534337a678db007a9f2d106e550edf0b7af15e27f862932efe5739605fce1be7072babd75b66d2136553f4aa9bab09ebc459887fe74b6a3404a2b856cb9d04898d7f108532b5106c1c2497cfbf8f898ad806aef9141ced7a4f599bf5a9bbf3897715d385b53a7c6383bbe29536f7081645757ff49752f179f6f5b67dee2d3ffec459a3ff2357043da41e5316b2553e227e637e024bb920cf4b17f5795172d894afa9c4ed8b7f20b011865a75f0b350f0d992c61f0ab32c8bb5fb37663d233f5d760929089152e8e67a06440d21964d80a6739d9107fe5a5a8c20865a1564d87539b8ebac2c4706574d27f20545dc3d0be3889eb813e756454d3ff65b59dd25e26215042277394e9e63528a6ed49ab73b5ee9ed8748af7b398412977a612c3de6742579336c4facc685e860caabe11e702a2d35fa90e102c366fa49d5901dec9c9c3160f6fa009e1bf98daa45c8ba602b45aec68746fc900b6b1cdcdd093083177af92cbc92560da19a394724023a0be51df679b56552b4d864114de644ae835c2be6d63f43c299718bf8291fd82d851883d60eafb18df4d0b67c05f46b762d402cba5e542b4aa15b5602fcc58d50c8c8c8f08483db5827dc73fc566a7586736000eb2398679bdec5d75e19cbf27b718b5a49baa5dfd619c3fab2e1c4ce55dad81c255c9831a56ba34092a668bd23730889f352568ef5900f3e5e8d9818f01ae2716d52d57d900ef21f384c652957a86bb0b02f09e06a5680cb71fd4cd49dd987fc20899dc94395343c66858f6251c4c551931a6d9689bf39b2c6099aa68f245c861c5e9bfee558fa34554540fb70ad2cdd82e8012eb0549bbf5ee54389371a0873e0979f8dffc5d07a38918e929c656598689fc0e22d7518db3afb8b98d15a85566d7a79e606fa2361fd5c23cfd4524dbdffd18b9c20e7831157ff7698c99ea7c89b3b96b2a953ff3cd14b13409420266a94f25cdeb42b73b204dab14152a524c305868f953437e617cf684bcaf830c70c03f9eda7c4e4285b0daf51616b4bc85a382453bdbae77e47efd59187aab7e830f7f3c89bea9c7c4320c4083b62d3e463b25c1a44ec533e59ac6655e58c83d74fd486e2a0be3f8abd286f63f1c3588952b4d450e6e6aef852b851333ab35d0c988abceca1214abdae167ce5619d928feefc2f5e9df8d69c18fef9991913db004fc2cac1364921b7ae32403053462cb73ac1ce0451ab4d9e42ab43173c220d07c2ac75d49516931255bd01a0579d0384dfc11f38c2096aa9f712a7e18ec47ef87c96b5361519bca5ac4d91531f37a66b1a05a608b31b47f0f12b03f57baad37bd89a9b55f9226666c91368484b8a52e1063017c4053164b6d1ed2c878ad18f55a31594ff861be559b69db7820f7797f30ae8eb741dbac88133aae587be50de12ef170aabdc6814f86c2e2e22ee7495129da03ae26faa9bcc2486af1599f512285ffc685759f603c7f0f5a44a44952777108e18b51b130bf3053fbe81d5072329a4516959742b515c614802c05e7372cb99506613c221db9c5112c9954f634f4b76541069a32b2c5b84ae0722c7b31abeac062f5771c623ffd63b29e80fd4473aa050c61e0082204dab08eae46d6c8f5ee57e966c3e76d95aa306d9e657e5158dcef89d5b3803e24a7bacae21b343cdd3bc4fa1fb39277297f7e10f458850707d3fc63a6846869ada861adc4b5db9b3dd444914e503c581adf6a50829d02da4bf159c52b2054c0cd803dce836cc8c4f779d9531350cfc4aff2cb67472446c048b653a907a79065f4a348a75535810cac32a9be0a457c3a77574e874b5dc5afaac15f4355606f0c5ab1f1574c9c1012846325729c425fc19c81b2a58f23a9c8b83838b02fa8abdaafc0956c5719454636465ce361a2dac62f7387fcfd45c4e275f9f28a37261b5a7ff092d3425c1fb9e58de40b6c59c1cfbb6ac381e7c8da782ab6e57017d1666cad7262de4a8d013ebb9f38645654b81635f8cb0b9ebf8fb223253c14b3f5336ca903490ca689627711822a054e97256626ba966b23622ca0f7607f401e0bfa9af5b03e047eabec6bf88758d2d10796db05299458e7c1ef4a0a549fe87cb6cd9d65331d81e94d8bc13e219e461acc41422dce0724e376f214cec8831780a407d03e4a98fa2239672ebd4508f33bee87c23090f3dd4293c5ca48ce0b66757ba612dd09d627a516040e272cd4f84fd5ac1111c41fc7494765968cb1a363e2fef7163fc14b7b587652c25bb3bc8af571778bf5721c2505ef4ffab711d705fc52e742ffbb85210388e922c3f4e411614a2d76502af1790ac9d3ed4d864ec1532750654efa863318f42aced8c2ef6a3bf4d557e87aacc5aa6669cec42903dc102415da7b63171af502c2696788d6f11713e23829d75449d6314659457c40e32f9a6c0a4354bd2610018bfbe3cb754968c09ef3a431284da169f78e0f85ea54b011ce6a9e404155ad296f515ae965e2646f5872c5edc341dbb97dcd1e218f78027f1c49e744433eceaf780227c54052ae26dea960a38d7c9bc2fb377cd9fb680d11a461de21799d3eb13595372019db9560a38d45d6be52b8b1c2ebfbcbf64e398229cde31c5807a2656606f6ed919aef03918f7e190f706a119e75ac22ff174d5c87f35308407341a55dda2bfad8c61367cb30c064049e7bc639281199eab0e88511480972ec554bd08ef5adad8fddc0c957d8f9491a7ca8c3bdaf2d754cff3115cc4e47314985d4dc7251075d1cf5fa4d5300b6ab6a7d2e0380b3a78cf887df72ba726865222ab0c9593973f23f49eb7c7ee3db20d440177074edefcd13b663263c585ff510ac897f2ced5407fa925a8d88d753dfe18b8701dec8bf85a89d49130d4c3a6b363ecfa7979ba6544677cc5362c977e26028dc9915b225d32649f41c163373982bcc8997368e74ce1b7b560524744264509ee6d3a9f4f25d4e62457e89c9e79ba2fc03e5ee98ba675d33314b70bdce04009f765f5c4a13d27bc1f8d01390d6bc3cf9b27df8ee717325885c761d631d3725de78db06772fc6f01bf87c2acc1ca167e37927f62118ee4f66a1af86cf81a2fdc7bce38ef5184f4f091fa2302e4ef0d9adc5776bd4e134ffc52eb88d4c125e4bd5093f2e5f2c16449887e4bd1641733a0f551ba924a2b1f8f37f76d2ad30a64111228503c48e0a48b1aae7558908f2ec77f38d293433b60fc0ee61e4943cbf2cb5b848e204dfd1782aa7bc5e24eb0135e0ed9a99a0ad30f3825d7feca1ce6ed2321abfe904f8c813b22967232f7e65db081fe4d2401f461e4a9b74242b400ec60eb36b2b2d1ca49084690b84f3d6b24a812e8c4633ce60966196819178f4451d4f3b8108455ad78706413d829ef6d73140aaef89c4f51a6fcf861029679a1035956309bebd01badf44eeb1d80b567764aa814e25ff118b542059881f7172fbd7cef4607de3117dafc725dad7f9a8ff7a627acadf4871596f7f5a3bcd872222e64144566b93a1d67966fefb9bf39d59ff84da74cf9130a61ae75d195fffc14e5b5a7e1b08094f1dea1388348280fd4995875a50086cac6070fbbcc60964ac176440fe4d36d556eac7cd2211367979b2bb9865bf63b32b2bebdc2b4a5c9075bf9916888742e488f6043d3c35aa649e9a07216c43a99170e456fe2c7d42af68bb7fd3535dea525959b8f26bd521884593960ef4fa3f3f02957df478044433244237b962b5f0f8950d92eefd4f6167145a2a1f4a45e92a3615888531c96186a97ee2f670105375a9162520ce2adf38896c34070cfaad1212eec218abdbd7e551b6bb77b746c9b35f5f09055c9fc390cac14449d5103479148e156531e1ee199fb6b1f6e66688a42e97e71bb57c86d660c0ddb91e9fd42901ea0f0973aeae10851f33f5ed7656d9f89eba7338422e91e52c65d80dbf4ac6fb81ad3f1d08b51f0c660cd49aff371bb9a973da33aae67a2f46702b29520f34fe0ade752ad57dca840dbaf23596d31b1dd3e502ffc3706421aa6d4ead2bf06065f204a4f65ef0a7d3422d2ac168da564a35b2afe5080e35269628fda1581b309319a42e208a9b6a931110d3ee044655177434381cf528c9095c352dc15b555cdcd83060cb8b7e5afcbc0a6fd56b4ab058290ae372436645903de31d46ad31ab246d4e01fa8713dc2d3942e80d4c163ddc844caea27808e922578c87c56730c5768e84aee05d83f97b10001377d545c34ea1ad46e0b314ef52fb426c29721e11caacd3cd46190c629f9973bf18071065b320d289a17a53176a9828c60019aae4bafee977c589b6e62523ba855c491f13de276c6fa200e0899bd04ac20684fcd1bfb78803ec303c1ee1fe5834bca4098c93864c7045d04d553ef863dd7ce6906df42a1c466765232e453d0e8d83fa3a699b6b6bd44a66809900f3fd89f3c4739288431b826b0aa06140b15a62fef4ebf8805e27c67bd1d60bfa6f5d467ea7b452a5942b9508225a7bdc3668963c155bbc2a97f9e33443188b311cb8c1702976f4591a95df6e22b479b7aa1f52e3b138f42cbc7a335d0a4b1350e0e2418c05e7cdcc69a83c73aa2b298b63483c177c6d3e5f4707004768ff3444219e9332e5f598e6418a105f728e548cf6ff55f8d4728fe25ce5cbe2f6efc9655abd45b8e5df7e0b7d8891abc292542b948db46e6fdf039b8951417240683b842605fac2d4180a211a9e69e16838125f818accb186b21297ab28400b9bc5183b9db556a4c48245e5c615e65844ad03a98ca097e878543548303d1d66d9a16503cf58158994685fd94927ff69254e0669fe9ca31bfb5bb8d563fde1a50bb9f8d8159e8da6846fe547421b00e99c3522817e345b9b6d7b7d755d28a0079be803d77a40e454654974806dbc26112c9dd8a8e839d9475ef2c0760dfc1de3a2cce9517df4b2ada705b41b2663160b720aafd5fc168e8ec4a642bf359a321da7b93fc3b845c9a618a64ba7d02cc281e04a4a8135fd20a682d888e60195c83901dd341e2048824730662b9cb2fb79ac7d14a9aa2a9d1469e4a3eb39546bc843e1462ddd02c357d89826c61b34dcc745f911ba3b499faee39eab9a313c400d7cefca61ccc4c9481b8d0fd875b9ce703522cac527e5c676c9da80c8855b0892436c44d8b3c9cbdb6d3f037b5e945ee3dcbbb98e7be2f6610920e1b3acb506d1e24e495c699d0c356721094718e8f21a2fcca301937a2c1396a5006a631cddc91b833047686fda25ac6b688c1e79e3491f1898c1192c84630f174aef496ad8e2cdf3023cede0e065857a3b8984b293142ce30839a5905393efc56cc87e476395c4cab7284fe5fd040ab3c2b2f3fbd210f4f9ab1c7a6bd66239bc9cbbc1c098329a2779d6878d24500d834461b7e358c7ecd73cb71383f16507cac9ee316c602c633cc516c7c8aa6450c401bc1f8425f7c35e9b3b947053ecbf2b70cf3dc6833075b803b5f1ae65efbf3c5f716354665eac836886b60c01ac8f06866cb182cf5b188ba093bcb5cc68909eeccb29d08ba4ea7d6e2ba5c2adcefe44caef09bda79f10caa302c35f5d6ee4a08f3b5d2ccf489c76640396f92c53c915baa9b8ea83185b06242f46229a625073a04dfb3605ee63b89621de4fd2b1b3e5beb3376926c05c67ff94e75826dd39ccc13a4a381fbc77bf15b7d83504bfc7a551a684a65527b8e68a53c0e8570ee9f5c027d5ff268de5e3f40d44e8043a1cf541275de8e8d63dbfff79841b260b904e32af0b37041f090f8b1e035ce3228cbe472fc7ae07618525bd95f1a615a72a1760d886eece14d9213bf1110a6437805bb0ac0f643db51408a9aa1311deacfb5800c20110fecb9c49f4516a6c44b8cf3beb12d8d2fff89b5f3d584ab971d193442a7fc59f97ce0579712fe7579f7e649b0a72def5d10d422b388e85687815bcd6d9bc7ee4c339060ed06ade6f886cc9d10ae44d4e04815554b2324415cc45736322e0239daf92038f303f00abe7f98d74ff299991a594bb084bb3426f5563ec7318c03977e16591ad3da62df66ccfef2e29782c0af72c20df268edf87b57a904e3a51dcac129ead888b98136b5b0acf7216f72999722a3e6e3de0937efcdae3e95e1e10e629aade01f13424d0970b99c7ff7a80d553e741a2a4f9a4b7c6cef9d93033096a1e2f98cb390a717921e606158874e3be7e11dd00a699f613549443711e92a60176a26dcd095bed1a993fd0e3ffd8e1d05012b97715c9af767fd8fdbe8f1a347de5c11678db6199220d98853a5340251abca5264b881317c57b03812e0a44ec6c502809402cc8cbbe8707c6dbde9b3d9146f6d2d52363f8083dfb6975f58ecdae993a30540a7de7b46ebb73e3ee2f8751a55e24265a901b500ad6e3c033022c7e1607e9b4090ca76f9137a85196978295617390a7fa5fdb5fd803aa8f698ca74d416739ed24bebe9421f9c381fef67b354cfe7f52eb741cf101930c32987d83e918bb5785d32e57153ef66e9c381f45b0f717d0ab5aea5c0da77dc2534ebf4167406d9e0cd147d932ad21eca178bf4108c8344af96c444cdf1e7645ac2dfca2022379fbce70c46beea00614e8985a80426f31e58b5298638dc4b2c4509ee1aa24de2d953a4c9c5e26b5fda3ceca2b5d11557276bfbc30baea5cea84c5debd6bdeb6bd0868b1eb9d7c1e0b910c370f2028fef7d9e916a12d738f1b68b27e7b3974805c580739fcfab197c8dbd66269d163eb7cbc2f9b23f139855916a09e7c37f4c0f3b34eb1c32fbb5be881a44df9d38015266b91b2e4e011fc2b77bd2ab31a1216abf7930dd7c9307102e28ecf55113cb3995b069a6a0b49989354c26a10ac383b6dd000eca3287fb061db82b08477689ad9a7a6f4b27706d298165a44d0b2733609fea20cc6d7429facb26798f6d155f9e149cc52f0920178297202a50ef2a259cad56b83a68ab83789a16f89a4f5ed76111e0cb02e9e47bf7d68335cf4b80eb05b68ed78ab94e461722eb1c4b10824e6e00c55d53d1764995d5d1b2bb3d592ad53612ee2bc5e5372872333278e03775c001c0f6069ebd7bd5f5b9d5ee77ec761f6aa05d1d45feff19c3e02328cce365184faa9b2614e198aee6283ea40b6138e1a9630926e8f5a888e569adf6873cb286166b5b6ec9b75840ae2cbe94d590458d7b3fb809165a5ff60bb63638bfc3989fc0a651b9e21a5b56cabde98f27ad80736bfaa38d584e2c6e1b44eaa2f826364ce973df24cacafa405fa051cea0d07740d418d11998ed712fdbff7c2914ca8a8c1c9a0a4a980763246da8315396675e8d1e6f94bff44644e2596c059e75f062f1f2a92e8ae478f489cc395239443c4b70ec568f0086b229499b7fe5d4dae79f350201328d2de08e0b0cc8dae80387730d1cc3ffb2c3397dab63f30db17e4f15850738e614b2485fac1a88875ff915ba41c0be1e4587e549eb527e6112b7ce1b8ca6bb57b89716a9c9b3a1bccbf2ab336b462345b26449b946f33fab14767e16b56c9c221f6ca50b01f8a1c0b67e3e3a45af8b82235c4eaf25b6f6ed67ddc27a7eba2db353ce74af7f67c4b96b10592e350cd10e6812e037e49483ec4b660a884825f38eb105ae2e0a234f13dbca7989f572b68a07aaa2ebec01dea263ada7369d99b15b119962b8979ed77ba75ea56e8c24bc2ec277ef8531ebcf327d38cc90886bea5d7027a4ced693e68916c863558018c65bbeceafce8ae30577ed4ee528c7e5012d2b4ce9ee3296a5aed6cafd4d5b7ae28349c5d787b0fc76cd2b0262407fc1aca0bce2b9abfd20131cd3cf655b8b17d47b9d3dec3d42e52b566d0dedd84b629451ff7e8bd466063dbaad659ec10bd34b023e63e9212fbbdde9113c5615051c19d5e7ca98ac7516580b9ffb4d2f9afe8eda29fca134cc63e1782e5c37602027f5e4c8ae0d8732eb5cb16a4275050eb88a39d6b23885801ac779f700e6986742963ade28479e16008646b402a5813b8cfb7a58f852f7434a7708d2cda296288d9c51b3d5092f7415302afc762d6706af6b7b83d6cdc60388be45dfddc2f743600d7a75e21257e24c0621421ab817cbe7b76273b7bd4991bee827e548fc5c0ba0b7aabcc882e07bc6433315fc809a523be86fe30652cc3ed8b6a9e470c61632cccd885d61fd6c2ec2abd1fac7112bf806a67dbe04ab5e116c921ef5b0aeae534d04eb4b563a89d4dda2ae9978822b28c88dbe0e939c8a8daa0201765aa32c6752f4056ddeffe45d80d3ac2e90fb5f4f860a6c7e83a29822b3b1abe56c21d5509c90d5c00d75831816efaca12f77b01801e8f24e04d9e66b67155ffa1f72fa46d7820b732db423ec436be752e1ffad07d29e4aaf74d8f1a4b275635932f52a7badfb7f1f005ff835a6e20e6669589b9ed179df33f4b246d4300fae7cd862767242c3499f8ce42bf58fb555177d2bd7983c7b768c63aca46ae4ee00df750316101fc6dc287a16259fc4b56e2779f04b4048a7068a2646e0a3d50f3ef3b1eb9d9536c09a97c3259e2c1d159f95598a847d5849ce135a0cde22f7718acce6171a345e58675dab35fc5f9719ab6d250c4110140c339c92b1aa1413a329ff8fa884c6e9c2dcef968529ec4ea2ff3b42feadae275b97f1c440f380047d5883ef3268bf5ddf0c1cf242ebef7a38942b0952440871eb3c26673a01e93aee9e08aa5bbdf6bb4d792759761c1624f76811ed59a68c1e88df5e4629047c0d5fcedb55345ed4456ca221e1863c1a311378fceed5e9f6ecaa95fcf10964418af77282b008e12f31ced16ce72fca7bf438d207fdeb7ce9698257d345d38edc7ca7b0604daadc2e17e90163da5d190642afc0b6c2bc354553a9619a89c9cb8acd5fde51739d8c661a8e73c350d3e49588362a5f709ae52fc8a0a2e3973f092a5f6a2f6ee9c1f2a2eefad3f9b75a50af12aab3d2b56d0b2f59439788ddd260bbf3babf7b6fac1e43287bf7bac763e588134e67c9d417e31476f1f403aa8d0a2862ebe4924982e722f12b6cbca5e0ae6ef4984bff661c57b945375cbbf92706ba28f82867f15002337806e559c48651d6c871d9b75345b162e9e0a9c0e2ddbbd8c5f79dc7fe627d8d4989ba9a3a4e7c341fca9bac736636dcae80645b7417ab19e3951639981348e9137d6cebd3d5a1fc0d4abb7b659177435c4c650e2cb31e2fe845bd3fdfc35941a9d61b8b478ddd79dbf99d2db381ce08f8a5a392c2a09f0ba3acbe7f130b2b4223cbe0b27da760280a14c6589cf36dc47166ac5c444a7a9b15ceda48110e37b5271cfdc757eb800a27a131503892ab295740946087e2ac98b7ae54e03d4f2af533227a2d5a652c691eed6103cde8ddda04dd0b3e304d71748cfa09b78edbb5cf5efbc9f7d65f95b4177fbcd3285281260f5b8d76e049c8c4f0f6f60b2f7903023791106865adaaa116c754f1aedfa76d29e7d7c94767ff1a7f2b0b352641244c349466dc661c6e45b67cb5287b3b2a16f4760d4e636bf1853c8952a3580140e0b4670aa5971e36c2f2238d6acb1e2f4235db27cc3e16007a29c616851e2369c30252388168f8c4861d8eba0d8699f21346bd04be221bf7ffd8896e36d156acde8ddbdfcc96803da155f605172e30563122142aa8a7cc5c86f59d8b23c5fa8672162e010cff7215226c68c9c9601f85db59b1be855ad323533ee2151509e009a79bb5f27357af2d83887036dcb74efb1b35cd4fab76f877597f5039e6fd5b7eb9ee61f55678fa9f0fb565976a32c25396678bb8c50feb773132376436de97a17288b2094e1d30bff17f8f6f20dca67be4492704fdcf786c35c935</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>加密</tag>
        <tag>项目</tag>
        <tag>MyBatis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>资源分享</title>
    <url>/2023/03/26/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="【架构师】零基础到精通——高可用"><a href="#【架构师】零基础到精通——高可用" class="headerlink" title="【架构师】零基础到精通——高可用"></a>【架构师】零基础到精通——高可用</h1><p> <a href="https://articles.zsxq.com/id_wfrwhhkqn8x3.html">https://articles.zsxq.com/id_wfrwhhkqn8x3.html</a></p>
<h1 id="数据结构可视化"><a href="#数据结构可视化" class="headerlink" title="数据结构可视化"></a>数据结构可视化</h1><p><a href="http://www.rmboot.com/Algorithms.html">http://www.rmboot.com/Algorithms.html</a></p>
<h1 id="Java常见设计模式总结"><a href="#Java常见设计模式总结" class="headerlink" title="Java常见设计模式总结"></a>Java常见设计模式总结</h1><p><a href="https://blog.csdn.net/a745233700/article/details/120371090?spm=1001.2014.3001.5502">https://blog.csdn.net/a745233700/article/details/120371090?spm=1001.2014.3001.5502</a></p>
<p><a href="https://chat.openai.com/chat/eec202d8-3609-45c3-85f6-e8092966ef00">技术 (openai.com)</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-优势成长</title>
    <url>/2023/03/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8A%BF%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/04/05/%E9%80%9A%E7%94%A8/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="软件开发原则"><a href="#软件开发原则" class="headerlink" title="软件开发原则"></a>软件开发原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>对于一个类只有一个引起它变化的原因</strong></p>
<p>一个类只负责尽可能独立的一项功能，尽可能少的职责</p>
<p>优点：</p>
<p>（1）功能单一，职责清晰。</p>
<p>（2）增强可读性，方便维护。</p>
<p>缺点：</p>
<p>（1）拆分得太详细，类的数量会急剧增加。</p>
<p>（2）职责的度量没有统一的标准，需要根据项目实现情况而定。</p>
<span id="more"></span>

<h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p><strong>对于扩展是开放的（Open for extension），对于更改是封闭的（Closed for modification）</strong></p>
<p>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。但是预先猜测是很难的，所以等到变化发生时立即采取行动，创建抽象来隔离以后发生的同类变化。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</p>
<p>开放-封闭原则是面向对象设计的核心所在。</p>
<h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p><strong>子类型必须能够替换掉它们的父类型</strong> </p>
<blockquote>
<p>「一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化」</p>
</blockquote>
<p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p>
<p>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><strong>针对接口编程，不要对实现编程</strong></p>
<p><strong>依赖倒转原则</strong></p>
<ul>
<li>A．高层模块不应该依赖低层模块。两个都应该依赖抽象。</li>
<li>B．抽象不应该依赖细节。细节应该依赖抽象。</li>
</ul>
<blockquote>
<p>做新项目时，发现业务逻辑的高层模块都是一样的，但客户却希望使用不同的数据库或存储信息方式，这时就出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与低层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。</p>
</blockquote>
<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><ul>
<li>创建型模式<ul>
<li>工厂方法模式</li>
<li>原型模式（克隆模式）</li>
</ul>
</li>
<li>行为型模式：类或者对象之间交互的行为，如何划分职责、更好的完成任务<ul>
<li>策略模式</li>
</ul>
</li>
<li>结构型模式：将类和对象结合在一起形成一个更强大的结构<ul>
<li>装饰模式</li>
<li>代理模式</li>
</ul>
</li>
</ul>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><blockquote>
<p>定义一个类负责创建其他类的实例，通过参数决定创建哪个类的实例</p>
</blockquote>
<h2 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h2><p>工厂类：负责创建对象</p>
<p>产品类：创建的产品的抽象类</p>
<p>具体产品类：具体实现的产品</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这是一个算法操作</p>
<p>工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Operation02 <span class="title function_">createOperation</span><span class="params">(String mathChar)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mathChar) &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="string">&quot;+&quot;</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AddOperation</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubOperation</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MulOperation</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DivOperation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产品类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operation02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> _numberA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> _numberB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">get_numberA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_numberA</span><span class="params">(<span class="type">double</span> _numberA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._numberA = _numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">get_numberB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_numberB</span><span class="params">(<span class="type">double</span> _numberB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._numberB = _numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体算法操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation02</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get_numberA() + get_numberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation02</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get_numberA() - get_numberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation02</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get_numberA() * get_numberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation02</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (get_numberB() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get_numberA() / get_numberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>产品有明显的继承关系，并且产品的类型不多</p>
<p>所有的产品有相同的方法和类似的属性，使用者希望通过参数获取到合适的对象</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote>
<p>策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
</blockquote>
<p>策略模式是一种定义一系列算法的方法。这些算法完成的都是相同的工作，只是实现不同，策略模式用相同的方法调用所有的算法，减少各种算法类与使用算法类之间的耦合。</p>
<p>策略模式的Strategy类层次为Context定义了一系列可供重用的算法和行为，提取出这些算法和行为中的公共功能。</p>
<p><strong>使用原因</strong></p>
<p>当不同的行为放在一个类中时，难以避免使用条件判断选择行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//算法方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgorithmInterface</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (条件A) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;算法A实现&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (条件B) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;算法B实现&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (条件C) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;算法C实现&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计要点-1"><a href="#设计要点-1" class="headerlink" title="设计要点"></a>设计要点</h2><p>策略模式主要有三个角色：</p>
<ol>
<li>上下文环境（Context）：承上启下的封装作用，屏蔽上层应用对策略的直接访问</li>
<li>策略的抽象（Strategy）：策略算法的抽象类，定义统一的接口，规定每个子类实现的方法</li>
<li>具体的策略实现</li>
</ol>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>将行为封装在独立的Strategy子类，根据不同的子类调用行为方法消除条件语句。</p>
<p>调用不同算法的示例：</p>
<p><strong>策略抽象的算法类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略抽象的算法类</span></span><br><span class="line"><span class="comment"> * 定义所有支持的算法的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//算法方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">AlgorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>具体实现的算法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体算法A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法A实现方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法A实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体算法B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//算法B实现方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法B实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体算法C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//算法C实现方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法C实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上下文环境，屏蔽了对具体算法的访问</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 上下文核心</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ContextInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.AlgorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于实例化不同的策略，最终调用context.ContextInterface时的结果也不同</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="策略模式和简单工厂模式的结合"><a href="#策略模式和简单工厂模式的结合" class="headerlink" title="策略模式和简单工厂模式的结合"></a>策略模式和简单工厂模式的结合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    context1.ContextInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，客户端只接触到了 Context 类， 没有接触到算法抽象类 Strategy，具体的算法彻底与客户端分离， 耦合更加降低。</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>在不同情况下使用不同的业务规则，考虑使用策略模式处理这种变化</p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<p>装饰模式是为已有功能动态地添加更多功能的一种方式。</p>
<p><strong>装饰模式的优点：</strong></p>
<p>有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</p>
<h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><p>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为。但这种做法的问题在于，它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * version 1</span></span><br><span class="line"><span class="comment"> * 装饰模式</span></span><br><span class="line"><span class="comment"> * 人穿衣服，给Person类添加穿某个衣服动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person1</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wearTShirt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;T恤 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wearJeans</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;牛仔裤 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wearJacket</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;夹克 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..... 等等穿方法 如果要增加装扮，需要修改person类 违背开闭原则</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;穿好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person1</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person1</span>(<span class="string">&quot;上春&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;穿衣服：&quot;</span>);</span><br><span class="line">        person1.wearTShirt();</span><br><span class="line">        person1.wearJeans();</span><br><span class="line">        person1.wearJacket();</span><br><span class="line">        person1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * version2</span></span><br><span class="line"><span class="comment"> * 提取穿衣服动作，抽象衣服 实现开闭原则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person2</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 穿好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做到了服饰与人 类的分离，但是这种方式衣服与人无关 只是将衣服一个一个词输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&quot;上春&quot;</span>);</span><br><span class="line">        <span class="type">TShirt</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TShirt</span>();</span><br><span class="line">        <span class="type">Jeans</span> <span class="variable">nzk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jeans</span>();</span><br><span class="line">        <span class="type">Jacket</span> <span class="variable">jk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jacket</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;穿衣服：&quot;</span>);</span><br><span class="line">        ts.show();</span><br><span class="line">        nzk.show();</span><br><span class="line">        jk.show();</span><br><span class="line">        person1.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服饰父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Finery</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShirt</span> <span class="keyword">extends</span>  <span class="title class_">Finery</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;T恤 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> <span class="keyword">extends</span>  <span class="title class_">Finery</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;牛仔裤 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jacket</span> <span class="keyword">extends</span>  <span class="title class_">Finery</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;夹克 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * version3</span></span><br><span class="line"><span class="comment"> * 装饰模式</span></span><br><span class="line"><span class="comment"> * 动态的给对象添加额外的职责，增加功能</span></span><br><span class="line"><span class="comment"> * 使用Person2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&quot;上春&quot;</span>);</span><br><span class="line">        <span class="type">TShirt</span> <span class="variable">tShirt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TShirt</span>();</span><br><span class="line">        <span class="type">Jacket</span> <span class="variable">jk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jacket</span>();</span><br><span class="line">        <span class="type">Jeans</span> <span class="variable">nzk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jeans</span>();</span><br><span class="line"></span><br><span class="line">        tShirt.Decorate(person1);</span><br><span class="line">        jk.Decorate(tShirt);</span><br><span class="line">        nzk.Decorate(jk);</span><br><span class="line">        nzk.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Finery2</span> <span class="keyword">extends</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被拓展的对象</span></span><br><span class="line">    Person2 person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Decorate</span> <span class="params">(Person2 person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里不是super.show 调用person.show 实际上是子类中调用实现对person.show方法的拓展</span></span><br><span class="line">        <span class="keyword">if</span>(person != <span class="literal">null</span>) &#123;</span><br><span class="line">            person.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShirt</span> <span class="keyword">extends</span> <span class="title class_">Finery2</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;T恤 &quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> <span class="keyword">extends</span> <span class="title class_">Finery2</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;牛仔裤 &quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jacket</span> <span class="keyword">extends</span> <span class="title class_">Finery2</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;夹克 &quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>为其他对象提供一种代理控制这个对象的访问，一个对象完成某项动作或任务，是通过对另一个对象的引用来完成的，这种模式叫代理模式。</p>
</blockquote>
<p>核心思想：</p>
<ul>
<li>使用一个额外的间接层来支持分散的、可控的、智能的访问。</li>
<li>增加一个包装和委托来保护真实的组件，以避免过度复杂。</li>
</ul>
<h2 id="设计要点-2"><a href="#设计要点-2" class="headerlink" title="设计要点"></a>设计要点</h2><p>代理模式中需要找到和区分三个角色</p>
<ol>
<li>主题：定义操作、活动、任务的接口</li>
<li>真实主题：真正完成操作、活动、任务的具体类</li>
<li>代理主题：代替真实主题完成操作、活动、任务的代理类</li>
</ol>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>主题类定义了一个操作: request()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实主题类实现了 request() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实主题类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理主题在进行代理真实主题的同时，进行了拓展请求前操作 preRequest() 和请求后操作 postRequest()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxySubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy preRequest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy postRequest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实</li>
<li>虚拟代理，不想或者不能直接引用一个对象时</li>
<li>安全代理，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限的时候。</li>
<li>智能指引，是指当调用真实的对象时，代理处理另外一些事</li>
</ol>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是对简单工厂模式的拓展优化，简单工厂模式中通过 switch case 方法创建对象，新增条件时增加 case 分支，违反了开闭原则。</p>
<p>针对这个问题，对工厂类进行抽象，分为工厂父类和不同的工厂子类，工厂子类创建不同的产品子类</p>
<p><strong>定义</strong></p>
<blockquote>
<p>定义一个创建对象（实例化对象）的接口，让子类来决定创建哪个类的实例。工厂方法使一个类的实例化延迟到其子类。</p>
</blockquote>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>工厂父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OperationFactory2</span> &#123;</span><br><span class="line">    MathOperation <span class="title function_">createOperation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加法工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddOperationFactory</span> <span class="keyword">implements</span> <span class="title class_">OperationFactory2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MathOperation <span class="title function_">createOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AddOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减法工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubOperationFactory</span> <span class="keyword">implements</span> <span class="title class_">OperationFactory2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MathOperation <span class="title function_">createOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乘法工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulOperationFactory</span> <span class="keyword">implements</span> <span class="title class_">OperationFactory2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MathOperation <span class="title function_">createOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MulOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 除法工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivOperationFactory</span> <span class="keyword">implements</span> <span class="title class_">OperationFactory2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MathOperation <span class="title function_">createOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DivOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与简单工厂相比"><a href="#与简单工厂相比" class="headerlink" title="与简单工厂相比"></a>与简单工厂相比</h2><p>简单工厂实现三个不同的加法操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">operation1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationFactory</span>().createOperation(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">operation2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationFactory</span>().createOperation(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">operation3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationFactory</span>().createOperation(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">operation1.set_numberA(<span class="number">1</span>);</span><br><span class="line">operation1.set_numberB(<span class="number">2</span>);</span><br><span class="line">System.out.println(operation1.getResult());</span><br><span class="line"></span><br><span class="line">operation2.set_numberA(<span class="number">2</span>);</span><br><span class="line">operation2.set_numberB(<span class="number">3</span>);</span><br><span class="line">System.out.println(operation2.getResult());</span><br><span class="line"></span><br><span class="line">operation3.set_numberA(<span class="number">4</span>);</span><br><span class="line">operation3.set_numberB(<span class="number">5</span>);</span><br><span class="line">System.out.println(operation3.getResult());</span><br></pre></td></tr></table></figure>

<p>当操作需要批量更改为其他时，<strong>需要修改三个createOperation中的参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MathOperation</span> <span class="variable">operation1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationFactory</span>().createOperation(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">operation2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationFactory</span>().createOperation(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">operation3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationFactory</span>().createOperation(<span class="string">&quot;-&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>而工厂方法实现三个加法操作，当操作批量统一修改时，只需要更改创建的工厂类 <code> AddOperationFactory()</code> 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="type">OperationFactory2</span> <span class="variable">addFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddOperationFactory</span>();</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">addOperation1</span> <span class="operator">=</span> addFactory.createOperation();</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">addOperation2</span> <span class="operator">=</span> addFactory.createOperation();</span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">addOperation3</span> <span class="operator">=</span> addFactory.createOperation();</span><br><span class="line">addOperation1.set_numberA(<span class="number">1</span>);</span><br><span class="line">addOperation1.set_numberB(<span class="number">2</span>);</span><br><span class="line">System.out.println(addOperation1.getResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addOperation2.set_numberA(<span class="number">2</span>);</span><br><span class="line">addOperation2.set_numberB(<span class="number">3</span>);</span><br><span class="line">System.out.println(addOperation2.getResult());</span><br><span class="line"></span><br><span class="line">addOperation3.set_numberA(<span class="number">4</span>);</span><br><span class="line">addOperation3.set_numberB(<span class="number">5</span>);</span><br><span class="line">System.out.println(addOperation3.getResult());</span><br></pre></td></tr></table></figure>



<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<h2 id="设计要点-3"><a href="#设计要点-3" class="headerlink" title="设计要点"></a>设计要点</h2><p>核心就是一个 Clone 方法，Clone 方法的功能就是拷贝父本的所有属性：</p>
<ol>
<li>分配一块新的内存空间给新的拷贝对象</li>
<li>拷贝父本对象的所有属性</li>
</ol>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>当拷贝父本有属性为引用对象时存在的问题。</p>
<p>采用浅拷贝是指只拷贝引用对象的指针，不拷贝引用类型对象指向的值。</p>
<p>深拷贝是指同时拷贝引用对象及其指向的指。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>通用技术</tag>
      </tags>
  </entry>
</search>
